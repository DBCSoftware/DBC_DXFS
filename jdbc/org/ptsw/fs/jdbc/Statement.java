/*******************************************************************************
 *
 * Copyright 2024 Portable Software Company
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.ptsw.fs.jdbc;

import java.io.IOException;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.util.Enumeration;
import java.util.Vector;

/**
 * <P>The object used for executing a static SQL statement
 * and obtaining the results produced by it.
 *
 * <P>Only one <code>ResultSet</code> object  per <code>Statement</code> object
 * can be open at any point in
 * time. Therefore, if the reading of one <code>ResultSet</code> object is interleaved
 * with the reading of another, each must have been generated by
 * different <code>Statement</code> objects. All statement <code>execute</code>
 * methods implicitly close a statment's current <code>ResultSet</code> object
 * if an open one exists.
 *
 * @see Connection#createStatement
 * @see ResultSet
 */

public class Statement implements java.sql.Statement {

private final Vector<SQLWarning> warnings = new Vector<SQLWarning>();
private final Message message;
private String rtcd;
private final Connection myCon; //The connection that made me.
private ResultSet openResultSet;
private String cursorName;
private boolean resultSetFromLastExecute;
private ResultSet lastExecuteResultSet;
private int lastExecuteUpdateCount;
private int stmtType;
private boolean escapeProcessing = true;
private boolean updateFlag = false;
private final int FSMajorVersion;

private static final int SELECT_STMT = 1;
private static final int OTHER_STMT = 3;
private static final int INSERT_STMT = 5;
private static final int UPDATE_STMT = 6;
private static final int DELETE_STMT = 7;
private static final int PS_UPDATE_STMT = 8;
private static final int PS_DELETE_STMT = 9;
private static final int ALTER_STMT = 10;
private static final int CREATE_STMT = 11;
private static final int DROP_STMT = 12;

Statement(Message msg, Connection con) {
	message = msg;
	myCon = con;
	stmtType = -1;
	FSMajorVersion = con.getFSMajorVersion();
}

int getFSMajorVersion() {
	return FSMajorVersion;
}

/**
 * Cancel can be used by one thread to cancel a statement that
 * is being executed by another thread.
 *
 * <P><B>FS NOTE:</B> FS does not support aborting an SQL statement.
 * A call to this method will be ignored.
 *
 */
@Override
public final void cancel() {
}

/**
 * After this call, getWarnings returns null until a new warning is
 * reported for this Statement.  
 *
 */
@Override
public final void clearWarnings() {
	warnings.removeAllElements();
}

/**
 * In many cases, it is desirable to immediately release a
 * Statements's database and JDBC resources instead of waiting for
 * this to happen when it is automatically closed; the close
 * method provides this immediate release.
 *
 * <P><B>Note:</B> A Statement is automatically closed when it is
 * garbage collected. When a Statement is closed, its current
 * ResultSet, if one exists, is also closed.  
 *
 * @exception SQLException if a database-access error occurs.
 */
@Override
public final void close() throws SQLException {
	initExecute(null);
	cursorName = null;
	if (myCon.closeStatement(this)) if (Driver.traceOn()) Driver.trace("Statement@close : Statement successfully closed.");
	else if (Driver.traceOn()) Driver.trace("Statement@close : Statement close attempt unsuccessful.");
}

/**
 * Execute a SQL statement that may return multiple results.
 * Under some (uncommon) situations a single SQL statement may return
 * multiple result sets and/or update counts.  Normally you can ignore
 * this, unless you're executing a stored procedure that you know may
 * return multiple results, or unless you're dynamically executing an
 * unknown SQL string.  The "execute", "getMoreResults", "getResultSet"
 * and "getUpdateCount" methods let you navigate through multiple results.
 *
 * The "execute" method executes a SQL statement and indicates the
 * form of the first result.  You can then use getResultSet or
 * getUpdateCount to retrieve the result, and getMoreResults to
 * move to any subsequent result(s).
 *
 * <P><B>FS2 NOTE:</B> FS2 does not support multiple results, therefore
 * this method is used only to execute an unknown SQL string..
 *
 * @param sql any SQL statement
 * @return true if the next result is a ResultSet; false if it is
 * an update count or there are no more results
 * @exception SQLException if a database-access error occurs.
 * @see #getResultSet
 * @see #getUpdateCount
 * @see #getMoreResults 
 */
@Override
public final boolean execute(String sql) throws SQLException {
	stmtType = (sql == null) ? -1 : getStmtType(sql);
	switch (stmtType) {
	case SELECT_STMT:
		executeQuery(sql);
		break;
	case INSERT_STMT:
	case UPDATE_STMT:
	case DELETE_STMT:
	case PS_UPDATE_STMT:
	case PS_DELETE_STMT:
	case DROP_STMT:
	case ALTER_STMT:
	case CREATE_STMT:
		executeUpdate(sql);
		break;
	default:
		if (Driver.traceOn()) Driver.trace("Statement@execute: throwing SQLException, statement: " + sql);
		throw new SQLException(Driver.bun.getString("UnSuppSqlStmt"));
	}
	return resultSetFromLastExecute;
}

/**
 * Execute a SQL statement that returns a single ResultSet.
 *
 * @param sql typically this is a static SQL SELECT statement
 * @return a ResultSet that contains the data produced by the
 * query; never null 
 * @exception SQLException if a database-access error occurs.
 */
@Override
public final java.sql.ResultSet executeQuery(String sql) throws SQLException {
	synchronized (message.getSock()) {
		sql = initExecute(sql); // assign stmtType
		if (escapeProcessing) sql = processEscapes(sql);
		if (stmtType != SELECT_STMT) {
			throw new SQLException(Driver.bun.getString("ExQuerySelect"));
		}
		message.setFunc("EXECUTE");
		message.setData(sql);
		try {
			message.sendMessage();
			message.recvMessage();
		}
		catch (IOException ioex) {
			throw new SQLException(ioex.getLocalizedMessage(), message.getLastErrorCode());
		}
		rtcd = message.getRtcd();
		if (Driver.traceOn()) Driver.trace("Statement@executeQuery: rtcd = " + rtcd);
		if (rtcd.startsWith("SET") || rtcd.startsWith("NONE")) {
			openResultSet = new ResultSet(new String(message.getData()), message, true, this);
		}
		else {
			openResultSet = new ResultSet(this);
		}
		if (cursorName != null) openResultSet.setCursorName(cursorName);
		resultSetFromLastExecute = true;
		lastExecuteResultSet = openResultSet;
		lastExecuteResultSet.setFSMajorVersion(FSMajorVersion);

		/* If the last sql select statement had the clause 'FOR UPDATE' in it then
		 * the FS will lock each record. We can tell the Result Set that
		 * his concurrency in Updatable.
		 */
		if (updateFlag) lastExecuteResultSet.setConcurrency(java.sql.ResultSet.CONCUR_UPDATABLE);
		return openResultSet;
	}
}

/**
 * Execute a SQL INSERT, UPDATE or DELETE statement.
 *
 * @param sql a SQL INSERT, UPDATE or DELETE statement.
 * @return row count for INSERT, UPDATE or DELETE.
 * @exception SQLException if a database-access error occurs.
 */
@Override
public final int executeUpdate(String sql) throws SQLException {
	synchronized (message.getSock()) {
		int rc = 0;
		sql = initExecute(sql); // assign stmtType
		if (escapeProcessing) sql = processEscapes(sql);
		switch (stmtType) {
		case SELECT_STMT:
			throw new SQLException(Driver.bun.getString("ExUpdate1"));
		case INSERT_STMT:
		case UPDATE_STMT:
		case DELETE_STMT:
		case PS_UPDATE_STMT:
		case PS_DELETE_STMT:
		case DROP_STMT:
		case ALTER_STMT:
		case CREATE_STMT:
			break;
		default:
			throw new SQLException(Driver.bun.getString("ExUpdate2"));
		}
		if (stmtType == PS_UPDATE_STMT || stmtType == PS_DELETE_STMT) {
			sql = processPS(sql);
			if (stmtType == PS_UPDATE_STMT) {
				message.setFunc("PSUPDATE");
				message.setData(sql);
			}
			if (stmtType == PS_DELETE_STMT) {
				message.setFunc("PSDELETE");
				message.setData(null);
			}
		}
		else {
			message.setFunc("EXECUTE");
			message.setData(sql);
		}
		try {
			message.sendMessage();
			message.recvMessage();
		}
		catch (IOException ioex) {
			throw new SQLException(ioex.getLocalizedMessage(), message.getLastErrorCode());
		}
		rtcd = message.getRtcd().toUpperCase();
		if (Driver.traceOn()) DriverManager.println("Statement@executeUpdate: rtcd = " + rtcd);

		if (rtcd.startsWith("OK") && message.getDataSize() > 0) {
			try {
				rc = Integer.parseInt(new String(message.getData()).trim());
			}
			catch (NumberFormatException ex) {
			}
			if (rtcd.startsWith("TRUNC", 2)) {
				SQLWarning w = new SQLWarning("String data, right truncated: Numeric or character truncation", "01004");
				if (warnings.isEmpty()) warnings.addElement(w);
				else warnings.firstElement().setNextWarning(w);
			}
		}

		resultSetFromLastExecute = false;
		lastExecuteUpdateCount = rc;
		return rc;
	}
}

/*
 * This method pre-processes a positioned update/delete statement.
 */
private String processPS(String sql) throws SQLException {
	String tmp = (sql.trim()).toUpperCase();
	String cursename = null;
	int i1, i2;
	int i3 = 0;
	String rsid = null;
	byte[] fid;
	byte[] fidOut = new byte[8];
	i1 = tmp.indexOf("WHERE CURRENT OF");
	i2 = i1 + 17;
	cursename = sql.substring(i2, sql.length());
	if (Driver.traceOn()) Driver.trace("Statement@processPS : cursename = " + cursename);
	i2 = 1;
	for (Enumeration<Statement> e = myCon.getStatementList(); e.hasMoreElements(); i2++) {
		Statement stmt = e.nextElement();
		if (stmt == this) continue;
		ResultSet rs = (org.ptsw.fs.jdbc.ResultSet) stmt.getResultSet();
		if (rs == null) continue;
		String scn = rs.getCursorName();
		if (scn == null) continue;
		if (Driver.traceOn()) Driver.trace("Statement@processPS : scn = " + scn);
		if (scn.equals(cursename)) {
			if (!(stmt.getUpdateStatus())) throw new SQLException(Driver.bun.getString("BadPSNoUpdate"));
			rsid = rs.getRsid();
			if (Driver.traceOn()) Driver.trace("Statement@processPS : found cursor, RSID = " + rsid);
			break;
		}
	}
	if (rsid == null) throw new SQLException(Driver.bun.getString("BadPSNoCursor"));
	fid = rsid.getBytes();
	i2 = fid.length - 1;
	i3 = 7;
	for (; i2 > -1; i2--, i3--) {
		fidOut[i3] = fid[i2];
	}
	for (; i3 > -1; i3--) {
		fidOut[i3] = (byte) ' ';
	}
	message.setFileId(new String(fidOut));
	return sql.substring(0, i1);
}

/*
 * When a new command is received we need to do some cleanup
 * If there is an open ResultSet, close it.
 * Clear any Warnings.
 * Set the instance variable stmtType.
 *
 * @param sql The SQL statement we have been asked to process
 * @exception SQLException
 */
private String initExecute(String sql) throws SQLException {
	updateFlag = false;
	closeResultSet();
	warnings.removeAllElements();
	if (sql != null) {
		sql = sql.trim();
		stmtType = getStmtType(sql);
	}
	if (Driver.traceOn()) Driver.trace("Statement@initExecute : statement type = " + stmtType);
	return sql;
}

private void closeResultSet() throws SQLException {
	lastExecuteUpdateCount = -1;
	if (openResultSet != null) {
		openResultSet.close();
		openResultSet = null;
	}
	if (lastExecuteResultSet != null) {
		lastExecuteResultSet.close();
		lastExecuteResultSet = null;
	}
}

/*
 * This routine assumes that 'stmt' has been trim()'d
 * Determine the SQL statement type by checking the first keyword
 *
 * @param stmt The SQL statement
 * @return A type code as an int.
 */
private int getStmtType(final String stmt) {
	int rc;
	String s1 = stmt.toUpperCase();
	if (s1.startsWith("SELECT")) rc = SELECT_STMT;
	else if (s1.startsWith("INSERT")) rc = INSERT_STMT;
	else if (s1.startsWith("UPDATE")) {
		if ((s1.indexOf("WHERE CURRENT OF")) != -1) rc = PS_UPDATE_STMT;
		else rc = UPDATE_STMT;
	}
	else if (s1.startsWith("DELETE")) {
		if ((s1.indexOf("WHERE CURRENT OF")) != -1) rc = PS_DELETE_STMT;
		else rc = DELETE_STMT;
	}
	else if (s1.startsWith("ALTER")) rc = ALTER_STMT;
	else if (s1.startsWith("DROP")) rc = DROP_STMT;
	else if (s1.startsWith("CREATE")) rc = CREATE_STMT;
	else rc = OTHER_STMT;
	if ((s1.indexOf("FOR UPDATE")) != -1) updateFlag = true;
	return rc;
}

/**
 * The maxFieldSize limit (in bytes) is the maximum amount of data
 * returned for any column value; it only applies to BINARY,
 * VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and LONGVARCHAR
 * columns.  If the limit is exceeded, the excess data is silently
 * discarded.
 *
 * @return the current max column size limit; zero means unlimited 
 */
@Override
public final int getMaxFieldSize() {
	return 32768;
}

/**
 * The maxRows limit is the maximum number of rows that a
 * ResultSet can contain.  If the limit is exceeded, the excess
 * rows are silently dropped.
 *
 * @return the current max row limit; zero means unlimited
 */
@Override
public final int getMaxRows() {
	return 0;
}

/**
 * getMoreResults moves to a Statement's next result.  It returns true if 
 * this result is a ResultSet.  getMoreResults also implicitly
 * closes any current ResultSet obtained with getResultSet.
 *
 * There are no more results when (!getMoreResults() &&
 * (getUpdateCount() == -1)
 *
 * <P><B>FS NOTE:</B> FS does not support multiple results, therefore
 * this method will always return false.
 *
 * @return always false
 * @see #execute 
 */
@Override
public final boolean getMoreResults() {
	try {
		closeResultSet(); // the implicit close
	}
	catch (Exception e1) {
	}
	return false;
}

/**
 * The queryTimeout limit is the number of seconds the driver will
 * wait for a Statement to execute. If the limit is exceeded, a
 * SQLException is thrown.
 *
 * @return the current query timeout limit in seconds; zero means unlimited 
 */
@Override
public final int getQueryTimeout() {
	return 0;
}

/**
 *  getResultSet returns the current result as a ResultSet.  It
 *  should only be called once per result.
 *
 * @return the current result as a ResultSet; null if the result
 * is an update count or there are no more results
 * @see #execute 
 */
@Override
public final java.sql.ResultSet getResultSet() {
	return (resultSetFromLastExecute) ? lastExecuteResultSet : null;
}

/**
 *  getUpdateCount returns the current result as an update count;
 *  if the result is a ResultSet or there are no more results, -1
 *  is returned.  It should only be called once per result.
 * 
 * @return the current result as an update count; -1 if it is a
 * ResultSet or there are no more results
 * @see #execute 
 */
@Override
public final int getUpdateCount() {
	// if there are no more results, lastExecuteUpdateCount = -1 
	return (resultSetFromLastExecute) ? -1 : lastExecuteUpdateCount;
}

/**
 * The first warning reported by calls on this Statement is
 * returned.  A Statment's execute methods clear its SQLWarning
 * chain. Subsequent Statement warnings will be chained to this
 * SQLWarning.
 *
 * <p>The warning chain is automatically cleared each time
 * a statement is (re)executed.
 *
 * <P><B>Note:</B> If you are processing a ResultSet then any
 * warnings associated with ResultSet reads will be chained on the
 * ResultSet object.
 *
 * @return the first SQLWarning or null 
 */
@Override
public final SQLWarning getWarnings() {
	if (warnings.isEmpty()) return null;
	return warnings.firstElement();
}

/**
 * setCursorname defines the SQL cursor name that will be used by
 * subsequent Statement execute methods. This name can then be
 * used in SQL positioned update/delete statements to identify the
 * current row in the ResultSet generated by this statement.  If
 * the database doesn't support positioned update/delete, this
 * method is a noop.  To insure that a cursor has the proper isolation
 * level to support update, the cursor's select statement should be
 * of the form 'select for update ...'. If the 'for update' clause is 
 * omitted the positioned updates may fail.
 *
 * <P><B>Note:</B> By definition, positioned update/delete
 * execution must be done by a different Statement than the one
 * which generated the ResultSet being used for positioning. Also,
 * cursor names must be unique within a Connection.
 *
 * <P>Step 1: Enumerate through my Connection's statements to make
 * sure that the new cursor name is unique.
 * Step 2: Let the ResultSet know his new name.
 *
 * @param name the new cursor name.  
 * @exception SQLException if new cursor name is non-unique.
 */
@Override
public final void setCursorName(final String name) throws SQLException {
	for (Enumeration<Statement> e = myCon.getStatementList(); e.hasMoreElements();) {
		Statement stmt = e.nextElement();
		if (stmt == this) continue;
		java.sql.ResultSet rs = stmt.getResultSet();
		if (rs == null) continue;
		String scn = rs.getCursorName();
		if (scn == null) continue;
		if (scn.equals(name)) throw new SQLException(Driver.bun.getString("DupCursorName"));
	}
	cursorName = name;
	if (openResultSet != null) openResultSet.setCursorName(name);
}

/**
 * If escape scanning is on (the default), the driver will do
 * escape substitution before sending the SQL to the database.
 *
 * Note: Since prepared statements have usually been parsed prior
 * to making this call, disabling escape processing for prepared
 * statements will like have no affect.
 *
 * @param enable true to enable; false to disable
 */
@Override
public final void setEscapeProcessing(boolean enable) {
	escapeProcessing = enable;
}

/**
 * The maxFieldSize limit (in bytes) is set to limit the size of
 * data that can be returned for any column value; it only applies
 * to BINARY, VARBINARY, LONGVARBINARY, CHAR, VARCHAR, and
 * LONGVARCHAR fields.  If the limit is exceeded, the excess data
 * is silently discarded. For maximum portability use values
 * greater than 256.
 *
 * <P><B>FS NOTE:</B> This method is ignored.
 *
 * @param max the new max column size limit; zero means unlimited 
 */
@Override
public final void setMaxFieldSize(int max) {
}

/**
 * The maxRows limit is set to limit the number of rows that any
 * ResultSet can contain.  If the limit is exceeded, the excess
 * rows are silently dropped.
 *
 * <P><B>FS NOTE:</B> This method is ignored.
 *
 * @param max the new max rows limit; zero means unlimited 
 */
@Override
public final void setMaxRows(int max) {
}

/**
 * The queryTimeout limit is the number of seconds the driver will
 * wait for a Statement to execute. If the limit is exceeded, a
 * SQLException is thrown.
 *
 * <P><B>FS NOTE:</B> This method is ignored.
 *
 * @param seconds the new query timeout limit in seconds; zero means 
 * unlimited 
 */
@Override
public final void setQueryTimeout(int seconds) {
}

/*
 * Package visibility accessor function
 * to get the Connection object that made this Statement.
 *
 * @return a Connection
 */
@Override
public java.sql.Connection getConnection() {
	return myCon;
}

/*
 * This method processes escape sequences in the sql string.
 * Currently, the only escape supported by FS is the left outer
 * join escape (oj).
 */
protected String processEscapes(String sql) throws SQLException {
	int i1, i2;
	StringBuffer sb = new StringBuffer();
	String retStr = null;
	String escType = null;
	i1 = sql.indexOf('{');
	if (i1 != -1 && !(i1 > 0 && sql.charAt(i1 - 1) == '\\')) { /* '{' found and not escaped */
		sb.append(sql.substring(0, i1++));
		while ((i1 < sql.length()) && (sql.charAt(i1) == ' '))
			i1++;
		i2 = i1;
		while ((i2 < sql.length()) && (sql.charAt(i2) != ' '))
			i2++;
		if (i2 < sql.length()) {
			escType = sql.substring(i1, i2);
			if (escType.equals("escape")) {
				/* remove brackets */
				i2 = sql.indexOf('}');
				if (i2 == -1) throw new SQLException(Driver.bun.getString("BadEscBrack"));
				sb.append(sql.substring(i1, i2));
				sb.append(sql.substring(i2 + 1, sql.length()));
				retStr = sb.toString();
			}
			else if (escType.equals("oj") || escType.equals("ts")) {
				i2 = sql.indexOf('}');
				if (i2 == -1) throw new SQLException(Driver.bun.getString("BadEscBrack"));
				if (sql.charAt(i1 + 2) == ' ') i1++; /* don't copy space */
				sb.append(sql.substring(i1 + 2, i2));
				sb.append(sql.substring(i2 + 1, sql.length())); /* copy everything after '}' */
				retStr = sb.toString();
				if ((retStr.indexOf('{') != -1) || (retStr.indexOf('}') != -1)) throw new SQLException(Driver.bun.getString("BadEsc"));
			}
			else if (escType.equals("d") || escType.equals("t")) {
				i2 = sql.indexOf('}');
				if (i2 == -1) throw new SQLException(Driver.bun.getString("BadEscBrack"));
				if (sql.charAt(i1 + 1) == ' ') i1++; /* don't copy space */
				sb.append(sql.substring(i1 + 1, i2));
				sb.append(sql.substring(i2 + 1, sql.length())); /* copy everything after '}' */
				retStr = sb.toString();
				if ((retStr.indexOf('{') != -1) || (retStr.indexOf('}') != -1)) throw new SQLException(Driver.bun.getString("BadEsc"));
			}
			else throw new SQLException(Driver.bun.getString("BadEscType"));
		}
		else {
			throw new SQLException(Driver.bun.getString("BadEscBrack"));
		}
	}
	else {
		sb.append(sql.substring(0, sql.length()));
		retStr = sb.toString();
	}
	return retStr;
}

/*
 * This method tells whether or not this Statement was prepared 'FOR UPDATE'
 */
protected boolean getUpdateStatus() {
	return updateFlag;
}

/*
 * This method returns the current cursor name.
 */
protected String getCursorName() {
	return cursorName;
}

//--------------------------JDBC 2.0-----------------------------

/**
 * Gives the driver a hint as to the direction in which
 * the rows in a result set
 * will be processed. The hint applies only to result sets created
 * using this <code>Statement</code> object.  The default value is
 * <code>ResultSet.FETCH_FORWARD</code>.
 * <p>Note that this method sets the default fetch direction for
 * result sets generated by this <code>Statement</code> object.
 * Each result set has its own methods for getting and setting
 * its own fetch direction.
 *
 * <P><B>FS NOTE:</B> This method is ignored.
 *
 * @param direction the initial direction for processing rows
 * @exception SQLException if a database access error occurs
 * or the given direction
 * is not one of <code>ResultSet.FETCH_FORWARD</code>,
 * <code>ResultSet.FETCH_REVERSE</code>, or <code>ResultSet.FETCH_UNKNOWN</code>
 * @since 1.2
 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
 *      2.0 API</a>
 */
@Override
public final void setFetchDirection(int direction) {
}

/**
 * Retrieves the direction for fetching rows from
 * database tables that is the default for result sets
 * generated from this <code>Statement</code> object.
 * If this <code>Statement</code> object has not set
 * a fetch direction by calling the method <code>setFetchDirection</code>,
 * the return value is implementation-specific.
 *
 * @return the default fetch direction for result sets generated
 *          from this <code>Statement</code> object
 * @exception SQLException if a database access error occurs
 * @since 1.2
 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
 *      2.0 API</a>
 */
@Override
public final int getFetchDirection() {
	return java.sql.ResultSet.FETCH_FORWARD;
}

/**
 * Gives the JDBC driver a hint as to the number of rows that should
 * be fetched from the database when more rows are needed.  The number
 * of rows specified affects only result sets created using this
 * statement. If the value specified is zero, then the hint is ignored.
 * The default value is zero.
 *
 * <P><B>FS NOTE:</B> This method is ignored.
 *
 * @param rows the number of rows to fetch
 * @exception SQLException if a database access error occurs, or the
 * condition 0 <= rows <= this.getMaxRows() is not satisfied.
 * @since 1.2
 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
 *      2.0 API</a>
 */
@Override
public final void setFetchSize(int rows) {
}

/**
 * Retrieves the number of result set rows that is the default
 * fetch size for result sets
 * generated from this <code>Statement</code> object.
 * If this <code>Statement</code> object has not set
 * a fetch size by calling the method <code>setFetchSize</code>,
 * the return value is implementation-specific.
 * @return the default fetch size for result sets generated
 *          from this <code>Statement</code> object
 * @exception SQLException if a database access error occurs
 * @since 1.2
 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
 *      2.0 API</a>
 */
@Override
public final int getFetchSize() {
	return 0;
}

/**
 * Retrieves the result set concurrency for <code>ResultSet</code> objects
 * generated by this <code>Statement</code> object.
 *
 * @return either <code>ResultSet.CONCUR_READ_ONLY</code> or
 * <code>ResultSet.CONCUR_UPDATABLE</code>
 * @since 1.2
 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
 *      2.0 API</a>
 */
@Override
public final int getResultSetConcurrency() {
	return java.sql.ResultSet.CONCUR_READ_ONLY;
}

/**
 * Retrieves the result set type for <code>ResultSet</code> objects
 * generated by this <code>Statement</code> object.
 *
 * @return one of <code>ResultSet.TYPE_FORWARD_ONLY</code>,
 * <code>ResultSet.TYPE_SCROLL_INSENSITIVE</code>, or
 * <code>ResultSet.TYPE_SCROLL_SENSITIVE</code>
 * @since 1.2
 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC
 *      2.0 API</a>
 */
@Override
public final int getResultSetType() {
	int fsmv = myCon.getFSMajorVersion();
	return (fsmv > 2) ? java.sql.ResultSet.TYPE_SCROLL_INSENSITIVE : java.sql.ResultSet.TYPE_FORWARD_ONLY;
}

/**
 * JDBC 2.0
 *
 * Adds a SQL command to the current batch of commmands for the statement.
 * This method is optional.
 *
 * <P><B>FS2 NOTE:</B> FS2 does not support batch processing.
 *
 * @param sql typically this is a static SQL INSERT or UPDATE statement
 * @exception SQLException always.
 */
@Override
public final void addBatch(String sql) throws SQLException {
	throw new SQLException(Driver.bun.getString("NoBatch"));
}

/**
 * JDBC 2.0
 *
 * Make the set of commands in the current batch empty.
 * This method is optional.
 *
 * <P><B>FS NOTE:</B> FS does not support batch processing.
 *
 * @exception SQLException always.
 */
@Override
public final void clearBatch() throws SQLException {
	throw new SQLException(Driver.bun.getString("NoBatch"));
}

/**
 * JDBC 2.0
 * 
 * Submit a batch of commands to the database for execution.
 * This method is optional.
 *
 * <P><B>FS NOTE:</B> FS does not support batch processing.
 *
 * @return an array of update counts containing one element for each
 * command in the batch.  The array is ordered according 
 * to the order in which commands were inserted into the batch
 * @exception SQLException always.
 */
@Override
public final int[] executeBatch() throws SQLException {
	throw new SQLException(Driver.bun.getString("NoBatch"));
}

@Override
public boolean getMoreResults(int arg0) throws SQLException {
	return false;
}

@Override
public java.sql.ResultSet getGeneratedKeys() throws SQLException {
	return null;
}

@Override
public int executeUpdate(String arg0, int arg1) throws SQLException {
	return 0;
}

@Override
public int executeUpdate(String arg0, int[] arg1) throws SQLException {
	return 0;
}

@Override
public int executeUpdate(String arg0, String[] arg1) throws SQLException {
	return 0;
}

@Override
public boolean execute(String arg0, int arg1) throws SQLException {
	return false;
}

@Override
public boolean execute(String arg0, int[] arg1) throws SQLException {
	return false;
}

@Override
public boolean execute(String arg0, String[] arg1) throws SQLException {
	return false;
}

@Override
public int getResultSetHoldability() throws SQLException {
	return 0;
}

@Override
public boolean isClosed() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

@Override
public boolean isPoolable() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

@Override
public void setPoolable(boolean poolable) throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public boolean isWrapperFor(Class<?> iface) throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

@Override
public <T> T unwrap(Class<T> iface) throws SQLException {
	// TODO Auto-generated method stub
	return null;
}

@Override
public void closeOnCompletion() throws SQLException {
	// TODO Auto-generated method stub
	
}

@Override
public boolean isCloseOnCompletion() throws SQLException {
	// TODO Auto-generated method stub
	return false;
}

}
