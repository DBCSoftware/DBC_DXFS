/*******************************************************************************
 *
 * Copyright 2024 Portable Software Company
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

package org.ptsw.fs.jdbc;

import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.CharArrayReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.NClob;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.text.MessageFormat;
import java.util.Map;
import java.util.StringTokenizer;
import java.util.Vector;

/**
 * <P>
 * A ResultSet provides access to a table of data. A ResultSet object is usually generated by executing a Statement.
 * 
 * <P>
 * A ResultSet maintains a cursor pointing to its current row of data. Initially the cursor is positioned before the
 * first row. The 'next' method moves the cursor to the next row.
 * 
 * <P>
 * The getXXX methods retrieve column values for the current row. You can retrieve values either using the index
 * number of the column, or by using the name of the column. In general using the column index will be more
 * efficient. Columns are numbered from 1.
 * 
 * <P>
 * For maximum portability, ResultSet columns within each row should be read in left-to-right order and each column
 * should be read only once.
 * 
 * <P>
 * For the getXXX methods, the JDBC driver attempts to convert the underlying data to the specified Java type and
 * returns a suitable Java value. See the JDBC specification for allowable mappings from SQL types to Java types with
 * the ResultSet.getXXX methods.
 * 
 * <P>
 * Column names used as input to getXXX methods are case insensitive. When performing a getXXX using a column name,
 * if several columns have the same name, then the value of the first matching column will be returned.
 * The column name option is designed to be used when column names are used in the SQL query. For columns that
 * are NOT explicitly named in the query, it is best to use column numbers. If column names were used there is no
 * way for the programmer to guarantee that they actually refer to the intended columns.
 * 
 * <P>
 * A ResultSet is automatically closed by the Statement that generated it when that Statement is closed,
 * re-executed, or is used to retrieve the next result from a sequence of multiple results.
 * 
 * <P>
 * The number, types and properties of a ResultSet's columns are provided by the ResulSetMetaData object
 * returned by the getMetaData method.
 * 
 * @see Statement#executeQuery
 * @see Statement#getResultSet
 * @see ResultSetMetaData
 */

@SuppressWarnings("deprecation")
public final class ResultSet implements java.sql.ResultSet {

	private String[] colNames;
	private String[] colSizes;
	private char[] colTypes;
	private String[] colAlias;
	private String[] colLabel;
	private String[] colTableName;
	private String[] colTableAlias;
	private final Message connectMsg; // Message object to use
	private int currentRow; // This is 1 based
	private String cursorName; // User assigned cursor name, if any
	private int[] displayWidth;
	private final int numCols; // Number of columns in this result set
	private final boolean realData; // false if this RS is meta data
	private final String rsid; // This result set ID
	private CommonType[] values; // Array of pointers to value objects
	private final Vector<SQLWarning> warnings = new Vector<SQLWarning>();
	private boolean openFlag;
	protected boolean isEmpty;
	private boolean isAfterLast = false;
	private boolean isOnValidRow = false;
	private boolean wasNull;
	private final Statement myStatement; // the Statement that made me
	private boolean emptyRS = false;
	private int FSMajorVersion;
	private int catalogType; // Is this RS for a Catalog function?
	private int rowCount;
	private int concurrency = ResultSet.CONCUR_READ_ONLY;

	static final ResultSet EMPTY_SET = new ResultSet(new String[0]);

	static {
		EMPTY_SET.isAfterLast = true;
	}

	ResultSet(Statement stmt) {
		openFlag = true;
		isEmpty = true;
		cursorName = null;
		displayWidth = null;
		myStatement = stmt;
		emptyRS = true;
		connectMsg = null;
		currentRow = 0;
		numCols = rowCount = 0;
		colNames = new String[0];
		realData = true;
		rsid = null;
		catalogType = Driver.CATALOG_NONE;
		if (Driver.traceOn()) Driver.trace("@ResultSet() empty normal ResultSet!");
	}

	ResultSet(String[] names) {
		connectMsg = null;
		myStatement = null;
		openFlag = true;
		currentRow = rowCount = 0;
		displayWidth = null;
		isEmpty = true;
		cursorName = null;
		numCols = names.length;
		colNames = new String[numCols];
		System.arraycopy(names, 0, colNames, 0, names.length);
		realData = false;
		emptyRS = true;
		rsid = null;
		catalogType = Driver.CATALOG_NONE;
		if (Driver.traceOn()) Driver.trace("@ResultSet() empty ResultSet!");
	}

	ResultSet(final String sData, final Message msg, final boolean rd, Statement stmt) throws SQLException {
		String sUpdatable, sNumRows;

		if (Driver.traceOn()) Driver.trace("@ResultSet(String, Message, boolean) sData = " + sData);
		if (Driver.traceOn()) Driver.trace("@ResultSet(String, Message, boolean) realData = " + rd);
		realData = rd;
		connectMsg = msg;
		myStatement = stmt;
		if (stmt != null) {
			FSMajorVersion = ((org.ptsw.fs.jdbc.Connection) stmt.getConnection()).getFSMajorVersion();
		}
		StringTokenizer tok = new StringTokenizer(sData, " ");
		rsid = tok.nextToken();
		cursorName = null;
		if (myStatement != null) {
			cursorName = myStatement.getCursorName();
			if (Driver.traceOn()) Driver.trace("@ResultSet : setting statement cursor name: " + cursorName);
		}
		if (cursorName == null) {
			cursorName = "C" + rsid;
			if (Driver.traceOn()) Driver.trace("@ResultSet : setting internal cursor name: " + cursorName);
		}

		sUpdatable = tok.nextToken();
		if (sUpdatable.equals("R") || sUpdatable.equals("W") || sUpdatable.equals("U")) {
			/*** CODE: UPDATABLE SETTINGS ARE BEING IGNORED ***/
			sNumRows = tok.nextToken();
		}
		else sNumRows = sUpdatable;

		if (sNumRows.equals("*")) rowCount = -1;
		else rowCount = Integer.parseInt(sNumRows);
		numCols = Integer.parseInt(tok.nextToken());
		colNames = new String[numCols];
		colTypes = new char[numCols];
		colSizes = new String[numCols];
		colAlias = new String[numCols];
		colLabel = new String[numCols];
		colTableName = new String[numCols];
		colTableAlias = new String[numCols];
		values = new CommonType[numCols];
		displayWidth = new int[numCols];

		for (int i1 = 0; i1 < numCols; i1++) {
			String nextCol = tok.nextToken();
			// this next line makes sure that the token is complete from '(' to ')'
			while (nextCol.indexOf(')') == -1)
				nextCol += " " + tok.nextToken();
			int i2 = nextCol.indexOf('(');
			colNames[i1] = nextCol.substring(0, i2);
			colTypes[i1] = nextCol.charAt(i2 + 1);
			if (FSMajorVersion < 3) {
				if (colTypes[i1] == 'C' || colTypes[i1] == 'N') {
					colSizes[i1] = nextCol.substring(i2 + 2, nextCol.length() - 1);
				}
			}
			else {
				String t, s1;
				int position = 0;
				int state = 1;
				s1 = nextCol.substring(i2 + 2);
				if (colTypes[i1] == 'C' || colTypes[i1] == 'N') {
					colSizes[i1] = String.valueOf(s1.charAt(position++));
					while (s1.charAt(position) != ',' && s1.charAt(position) != ')') {
						colSizes[i1] += s1.charAt(position++);
					}
				}
				/* this loop replaces StringTokenizer getnext() */
				for (t = ""; position < s1.length(); position++) {
					if (s1.charAt(position) == '\\') position++;
					else if (s1.charAt(position) == ')' || s1.charAt(position) == ',') {
						if (t.length() == 0) t += s1.charAt(position++);
						break;
					}

					t += s1.charAt(position);
				}
				while (!t.equals(")")) {
					if (!t.equals(",")) throw new SQLException("Bad RS <columninfo> format '" + nextCol + "'");
					/* this loop replaces StringTokenizer getnext() */
					for (t = ""; position < s1.length(); position++) {
						if (s1.charAt(position) == '\\') position++;
						else if (s1.charAt(position) == ')' || s1.charAt(position) == ',') {
							if (t.length() == 0) t += s1.charAt(position++);
							break;
						}
						t += s1.charAt(position);
					}
					if (!t.equals(",")) {
						if (state == 1) colAlias[i1] = t;
						else if (state == 2) colLabel[i1] = t;
						else if (state == 3) {
							if (!t.equals("*")) colTableName[i1] = t;
						}
						else if (state == 4) {
							if (!t.equals("*")) colTableAlias[i1] = t;
						}
						/* this loop replaces StringTokenizer getnext() */
						for (t = ""; position < s1.length(); position++) {
							if (s1.charAt(position) == '\\') position++;
							else if (s1.charAt(position) == ')' || s1.charAt(position) == ',') {
								if (t.length() == 0) t += s1.charAt(position++);
								break;
							}
							t += s1.charAt(position);
						}
					}
					else if (i1 >= 1) {
						if (state == 3) {
							if (colTableName[i1 - 1].length() > 0) colTableName[i1] = colTableName[i1 - 1];
						}
						else if (state == 4) {
							if (colTableAlias[i1 - 1].length() > 0) colTableAlias[i1] = colTableAlias[i1 - 1];
						}
					}
					state++;
				}
			}
			calcDisplayWidth(colTypes[i1], colSizes[i1], displayWidth, i1);
		}

		currentRow = 0; // Row index is 1 based, position before the first row.
		openFlag = true;
		isEmpty = (rowCount == 0);
		catalogType = Driver.CATALOG_NONE;
	}

	private void calcDisplayWidth(char type, String size, int[] dw, int index) {
		switch (type) {
		case 'C':
			dw[index] = Integer.parseInt(size);
			break;
		case 'N':
			int delim = size.indexOf((FSMajorVersion < 3) ? ',' : ':');
			if (delim == -1) dw[index] = Integer.parseInt(size);
			else dw[index] = Integer.parseInt(size.substring(0, delim)) + 1;
			break;
		case 'D':
			dw[index] = 10;
			break;
		case 'T':
			dw[index] = 12;
			break;
		case 'S':
			dw[index] = 23;
			break;
		default:
			dw[index] = 0;
			break;
		}
	}

	void setFSMajorVersion(int fsmv) {
		FSMajorVersion = fsmv;
	}

	void setConcurrency(int c) {
		if (FSMajorVersion >= 3 && (c == CONCUR_READ_ONLY || c == CONCUR_UPDATABLE)) concurrency = c;
	}

	/**
	 * After this call getWarnings returns null until a new warning is reported for this ResultSet.
	 * 
	 */
	@Override
	public void clearWarnings() {
		warnings.removeAllElements();
	}

	/**
	 * In some cases, it is desirable to immediately release a ResultSet's database and JDBC resources instead of
	 * waiting for this to happen when it is automatically closed; the close method provides this immediate release.
	 * 
	 * <P>
	 * <B>Note:</B> A ResultSet is automatically closed by the Statement that generated it when that Statement is
	 * closed, re-executed, or is used to retrieve the next result from a sequence of multiple results. A ResultSet is
	 * also automatically closed when it is garbage collected.
	 * 
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public void close() throws SQLException {
		synchronized (connectMsg.getSock()) {
			if (!openFlag) return;
			openFlag = false;
			if (isEmpty) return;
			if (realData) {

				connectMsg.setFunc("DISCARD");
				connectMsg.setFileId(rsid);
				connectMsg.setData(null);
				try {
					connectMsg.sendMessage();
					connectMsg.recvMessage(); // Must flush the 'OK' from incoming pipe
				}
				catch (IOException ioex) {
					throw new SQLException(ioex.getLocalizedMessage());
				}
			}

			warnings.removeAllElements();
			colNames = null;
			colTypes = null;
			colSizes = null;
			values = null;
			displayWidth = null;
			currentRow = 0;
			// rsid = null;
			cursorName = null;
			concurrency = CONCUR_READ_ONLY;
		}
	}

	/**
	 * Maps the given <code>ResultSet</code> column name to its <code>ResultSet</code> column index.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @return the column index of the given column name
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public int findColumn(final String columnName) throws SQLException {
		if (columnName != null) {
			for (int i1 = 0; i1 < numCols; i1++) {
				String alias = getColumnAlias(i1);
				if (alias == null) {
					if (columnName.equalsIgnoreCase(colNames[i1])) return i1 + 1;
				}
				else {
					if (alias.equalsIgnoreCase(columnName)) return i1 + 1;
				}
			}
		}
		if (Driver.traceOn()) Driver.trace("@ResultSet : findColumn() failed, column name = '" + columnName
				+ "'");
		throw new SQLException(MessageFormat.format(Driver.bun.getString("CantFindCol"),
				new Object[] { columnName }));
	}

	/**
	 * A column value can be retrieved as a stream of ASCII characters and then read in chunks from the stream. This
	 * method is particularly suitable for retrieving large LONGVARCHAR values. The JDBC driver will do any necessary
	 * conversion from the database format into ASCII.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to getting the value of any other column. The
	 * next call to a get method implicitly closes the stream. . Also, a stream may return 0 for available() whether
	 * there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a stream of one byte ASCII characters. If
	 *         the value is SQL NULL then the result is null.
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public InputStream getAsciiStream(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return new ByteArrayInputStream(values[columnIndex - 1].getBytes());
	}

	/**
	 * A column value can be retrieved as a stream of ASCII characters and then read in chunks from the stream. This
	 * method is particularly suitable for retrieving large LONGVARCHAR values. The JDBC driver will do any necessary
	 * conversion from the database format into ASCII.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to getting the value of any other column. The
	 * next call to a get method implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a stream of one byte ASCII characters. If
	 *         the value is SQL NULL then the result is null.
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public InputStream getAsciiStream(final String columnName) throws SQLException {
		return getAsciiStream(findColumn(columnName));
	}

	/**
	 * Get the value of a column in the current row as a java.math.BigDecimal object.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param scale
	 *            the number of digits to the right of the decimal
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 * @deprecated
	 */
	@Deprecated
	@Override
	public BigDecimal getBigDecimal(final int columnIndex, final int scale) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getBigDecimal(scale);
	}

	/**
	 * Get the value of a column in the current row as a java.math.BigDecimal object.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @param scale
	 *            the number of digits to the right of the decimal
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 * @deprecated
	 */
	@Deprecated
	@Override
	public BigDecimal getBigDecimal(final String columnName, final int scale) throws SQLException {
		return getBigDecimal(findColumn(columnName), scale);
	}

	/**
	 * A column value can be retrieved as a stream of uninterpreted bytes and then read in chunks from the stream. This
	 * method is particularly suitable for retrieving large LONGVARBINARY values.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to getting the value of any other column. The
	 * next call to a get method implicitly closes the stream. Also, a stream may return 0 for available() whether there
	 * is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a stream of uninterpreted bytes. If the
	 *         value is SQL NULL then the result is null.
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public InputStream getBinaryStream(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return new ByteArrayInputStream(getBytes(columnIndex));
	}

	/**
	 * A column value can be retrieved as a stream of uninterpreted bytes and then read in chunks from the stream. This
	 * method is particularly suitable for retrieving large LONGVARBINARY values.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to getting the value of any other column. The
	 * next call to a get method implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a stream of uninterpreted bytes. If the
	 *         value is SQL NULL then the result is null.
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public InputStream getBinaryStream(final String columnName) throws SQLException {
		return getBinaryStream(findColumn(columnName));
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>boolean</code> in the Java programming language.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is false
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public boolean getBoolean(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return false;
		return values[columnIndex - 1].getBoolean();
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>boolean</code> in the Java programming language.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is false
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public boolean getBoolean(final String columnName) throws SQLException {
		return getBoolean(findColumn(columnName));
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>byte</code> in the Java programming language.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public byte getByte(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return 0;
		return getBytes(columnIndex)[0];
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>byte</code> in the Java programming language.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public byte getByte(final String columnName) throws SQLException {
		return getByte(findColumn(columnName));
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>byte</code> array in the Java programming language. The bytes represent the raw values returned by the
	 * driver.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public byte[] getBytes(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getBytes();
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>byte</code> array in the Java programming language. The bytes represent the raw values returned by the
	 * driver.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public byte[] getBytes(final String columnName) throws SQLException {
		return getBytes(findColumn(columnName));
	}

	/**
	 * Gets the name of the SQL cursor used by this <code>ResultSet</code> object.
	 * 
	 * <P>
	 * In SQL, a result table is retrieved through a cursor that is named. The current row of a result set can be
	 * updated or deleted using a positioned update/delete statement that references the cursor name. To insure that the
	 * cursor has the proper isolation level to support update, the cursor's <code>select</code> statement should be of
	 * the form 'select for update'. If the 'for update' clause is omitted, the positioned updates may fail.
	 * 
	 * <P>
	 * The JDBC API supports this SQL feature by providing the name of the SQL cursor used by a <code>ResultSet</code>
	 * object. The current row of a <code>ResultSet</code> object is also the current row of this SQL cursor.
	 * 
	 * <P>
	 * <B>Note:</B> If positioned update is not supported, a <code>SQLException</code> is thrown.
	 * 
	 * @return the SQL name for this <code>ResultSet</code> object's cursor
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public String getCursorName() throws SQLException {
		return cursorName;
	}

	/*
	 * This package visibility method is called by the creating Statement object. The user wants to use his own cursor
	 * name in subsequent positioned Updates or Deletes.
	 * 
	 * If the user calls Statement.setCursorName then that name is passed into this open ResultSet. We use this for
	 * positioned Updates & Deletes.
	 * 
	 * @param s The cursor name the user wants to refer to us by
	 */
	void setCursorName(final String s) {
		cursorName = s;
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Date</code> object in the Java programming language.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL <code>NULL</code>, the value returned is <code>null</code>
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public java.sql.Date getDate(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getDate();
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Date</code> object in the Java programming language.
	 * 
	 * @param columnName
	 *            the SQL name of the column
	 * @return the column value; if the value is SQL <code>NULL</code>, the value returned is <code>null</code>
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public java.sql.Date getDate(final String columnName) throws SQLException {
		return getDate(findColumn(columnName));
	}

	/**
	 * Get the value of a column in the current row as a Java double.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public double getDouble(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return 0;
		return values[columnIndex - 1].getDouble();
	}

	/**
	 * Get the value of a column in the current row as a Java double.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public double getDouble(final String columnName) throws SQLException {
		return getDouble(findColumn(columnName));
	}

	/**
	 * Get the value of a column in the current row as a Java float.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public float getFloat(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return 0;
		return values[columnIndex - 1].getFloat();
	}

	/**
	 * Get the value of a column in the current row as a Java float.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public float getFloat(final String columnName) throws SQLException {
		return getFloat(findColumn(columnName));
	}

	/**
	 * Get the value of a column in the current row as a Java int.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public int getInt(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return 0;
		if (Driver.traceOn()) Driver.trace("@ResultSet : getInt(), column = " + columnIndex);
		return values[columnIndex - 1].getInt();
	}

	/**
	 * Get the value of a column in the current row as a Java int.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public int getInt(final String columnName) throws SQLException {
		return getInt(findColumn(columnName));
	}

	/**
	 * Get the value of a column in the current row as a Java long.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public long getLong(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return 0;
		return values[columnIndex - 1].getLong();
	}

	/**
	 * Get the value of a column in the current row as a Java long.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public long getLong(final String columnName) throws SQLException {
		return getLong(findColumn(columnName));
	}

	/**
	 * Retrieves the number, types and properties of this <code>ResultSet</code> object's columns.
	 * 
	 * @return the description of this <code>ResultSet</code> object's columns
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public java.sql.ResultSetMetaData getMetaData() {
		if (Driver.traceOn()) Driver.trace("ResultSet@getMetaData realData = " + realData);
		return new ResultSetMetaData(this, realData);
	}

	/**
	 * <p>
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as an
	 * <code>Object</code> in the Java programming language.
	 * 
	 * <p>
	 * This method will return the value of the given column as a Java object. The type of the Java object will be the
	 * default Java object type corresponding to the column's SQL type, following the mapping for built-in types
	 * specified in the JDBC specification.
	 * 
	 * <p>
	 * This method may also be used to read datatabase-specific abstract data types.
	 * 
	 * In the JDBC 2.0 API, the behavior of method <code>getObject</code> is extended to materialize data of SQL
	 * user-defined types. When a column contains a structured or distinct value, the behavior of this method is as if
	 * it were a call to: <code>getObject(columnIndex,
	 * this.getStatement().getConnection().getTypeMap())</code>.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a <code>java.lang.Object</code> holding the column value
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public Object getObject(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getObject();
	}

	/**
	 * <p>
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as an
	 * <code>Object</code> in the Java programming language.
	 * 
	 * <p>
	 * This method will return the value of the given column as a Java object. The type of the Java object will be the
	 * default Java object type corresponding to the column's SQL type, following the mapping for built-in types
	 * specified in the JDBC specification.
	 * 
	 * <p>
	 * This method may also be used to read datatabase-specific abstract data types.
	 * 
	 * In the JDBC 2.0 API, the behavior of the method <code>getObject</code> is extended to materialize data of SQL
	 * user-defined types. When a column contains a structured or distinct value, the behavior of this method is as if
	 * it were a call to: <code>getObject(columnIndex,
	 * this.getStatement().getConnection().getTypeMap())</code>.
	 * 
	 * @param columnName
	 *            the SQL name of the column
	 * @return a <code>java.lang.Object</code> holding the column value
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public Object getObject(final String columnName) throws SQLException {
		return getObject(findColumn(columnName));
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as an
	 * <code>Object</code> in the Java programming language. This method uses the given <code>Map</code> object for the
	 * custom mapping of the SQL structured or distinct type that is being retrieved.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> Since the FS system does not support TypeMaps, this method will always result in an SQLException.
	 * 
	 * @param i
	 *            the first column is 1, the second is 2, ...
	 * @param map
	 *            a <code>java.util.Map</code> object that contains the mapping from SQL type names to classes in the
	 *            Java programming language
	 * @return an <code>Object</code> in the Java programming language representing the SQL value
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public Object getObject(int i, Map<String, Class<?>> map) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoTypeMaps"));
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as an
	 * <code>Object</code> in the Java programming language. This method uses the given <code>Map</code> object for the
	 * custom mapping of the SQL structured or distinct type that is being retrieved.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> Since the FS system does not support TypeMaps, this method will always result in an SQLException.
	 * 
	 * @param columnName
	 *            the SQL name of the column
	 * @param map
	 *            a <code>java.util.Map</code> object that contains the mapping from SQL type names to classes in the
	 *            Java programming language
	 * @return an <code>Object</code> in the Java programming language representing the SQL value
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public Object getObject(String colName, Map<String, Class<?>> map) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoTypeMaps"));
	}

	/**
	 * Get the value of a column in the current row as a Java short.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public short getShort(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return 0;
		return values[columnIndex - 1].getShort();
	}

	/**
	 * Get the value of a column in the current row as a Java short.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is 0
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public short getShort(final String columnName) throws SQLException {
		return getShort(findColumn(columnName));
	}

	/**
	 * Get the value of a column in the current row as a Java String.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public String getString(final int columnIndex) throws SQLException {
		String s1 = null;
		if (checkCol(columnIndex)) {
			if (Driver.traceOn()) Driver.trace("@ResultSet : getString(), checkCol failed, index = "
					+ columnIndex);
			return null;
		}
		if (catalogType == Driver.CATALOG_TABLES || catalogType == Driver.CATALOG_COLUMNS) {
			// Remove trailing blanks for MacroMedia CF
			s1 = values[columnIndex - 1].getString().trim();
		}
		else s1 = values[columnIndex - 1].getString();
		if (Driver.traceOn()) Driver.trace("@ResultSet : getString(), column = " + columnIndex
				+ ", result = '" + s1 + "'");
		return s1;
	}

	/**
	 * Get the value of a column in the current row as a Java String.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public String getString(final String columnName) throws SQLException {
		return getString(findColumn(columnName));
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Time</code> object in the Java programming language.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL <code>NULL</code>, the value returned is <code>null</code>
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public java.sql.Time getTime(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getTime();
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Time</code> object in the Java programming language.
	 * 
	 * @param columnName
	 *            the SQL name of the column
	 * @return the column value; if the value is SQL <code>NULL</code>, the value returned is <code>null</code>
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public java.sql.Time getTime(final String columnName) throws SQLException {
		return getTime(findColumn(columnName));
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Timestamp object.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 does not support Timestamp,
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public java.sql.Timestamp getTimestamp(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getTimestamp();
	}

	/**
	 * Get the value of a column in the current row as a java.sql.Timestamp object.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 does not support Timestamp,
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return the column value; if the value is SQL NULL, the result is null
	 * @exception SQLException
	 *                if a database-access error occurs.
	 */
	@Override
	public java.sql.Timestamp getTimestamp(final String columnName) throws SQLException {
		return getTimestamp(findColumn(columnName));
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as as a stream
	 * of Unicode characters. The value can then be read in chunks from the stream. This method is particularly suitable
	 * for retrieving large<code>LONGVARCHAR</code>values. The JDBC driver will do any necessary conversion from the
	 * database format into Unicode. The byte format of the Unicode stream must be Java UTF-8, as specified in the Java
	 * virtual machine specification.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to getting the value of any other column. The
	 * next call to a <code>getXXX</code> method implicitly closes the stream. Also, a stream may return <code>0</code>
	 * when the method <code>InputStream.available</code> is called whether there is data available or not.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return a Java input stream that delivers the database column value as a stream in Java UTF-8 byte format; if the
	 *         value is SQL <code>NULL</code>, the value returned is <code>null</code>
	 * @exception SQLException
	 *                if a database access error occurs
	 * @deprecated use <code>getCharacterStream</code> in place of <code>getUnicodeStream</code>
	 */
	@Deprecated
	@Override
	public InputStream getUnicodeStream(final int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		byte[] b1 = values[columnIndex - 1].getBytes();
		byte[] b2 = new byte[(b1.length) * 2];
		int pos1, pos2;
		for (pos1 = 0, pos2 = 0; pos1 < b1.length; pos1++) {
			pos2 = pos1 * 2;
			b2[pos2] = 0x00;
			b2[pos2 + 1] = b1[pos1];
			if (Driver.traceOn()) {
				StringBuffer sb = new StringBuffer();
				sb.append("ResultSet@getUnicodeStream : hi byte " + pos1 + " : ");
				for (int i2 = 7; i2 >= 0; i2--)
					sb.append((b2[pos2] >> i2) & 0x01);
				sb.append("  lo byte " + pos1 + " : ");
				for (int i2 = 7; i2 >= 0; i2--)
					sb.append((b2[pos2 + 1] >> i2) & 0x01);
				sb.append("  char " + pos1 + " : ");
				sb.append((char) ((b2[pos2 + 1] & 0x00FF) + ((b2[pos2] & 0x00FF) << 8)));
				Driver.trace(sb.toString());
			}
		}
		return new ByteArrayInputStream(b2);
	}

	/**
	 * A column value can be retrieved as a stream of Unicode characters and then read in chunks from the stream. This
	 * method is particularly suitable for retrieving large LONGVARCHAR values. The JDBC driver will do any necessary
	 * conversion from the database format into Unicode.
	 * 
	 * <P>
	 * <B>Note:</B> All the data in the returned stream must be read prior to getting the value of any other column. The
	 * next call to a get method implicitly closes the stream.
	 * 
	 * @param columnName
	 *            is the SQL name of the column
	 * @return a Java input stream that delivers the database column value as a stream of two byte Unicode characters.
	 *         If the value is SQL NULL then the result is null.
	 * @exception SQLException
	 *                if a database-access error occurs.
	 * @deprecated
	 */
	@Deprecated
	@Override
	public InputStream getUnicodeStream(final String columnName) throws SQLException {
		return getUnicodeStream(findColumn(columnName));
	}

	/**
	 * <p>
	 * The first warning reported by calls on this ResultSet is returned. Subsequent ResultSet warnings will be chained
	 * to this SQLWarning.
	 * 
	 * <P>
	 * The warning chain is automatically cleared each time a new row is read.
	 * 
	 * <P>
	 * <B>Note:</B> This warning chain only covers warnings caused by ResultSet methods. Any warning caused by statement
	 * methods (such as reading OUT parameters) will be chained on the Statement object.
	 * 
	 * @return the first SQLWarning or null
	 */
	@Override
	public SQLWarning getWarnings() {
		if (warnings.isEmpty()) return null;
		return warnings.firstElement();
	}

	/**
	 * Moves the cursor down one row from its current position. A <code>ResultSet</code> cursor is initially positioned
	 * before the first row; the first call to the method <code>next</code> makes the first row the current row; the
	 * second call makes the second row the current row, and so on.
	 * 
	 * <P>
	 * If an input stream is open for the current row, a call to the method <code>next</code> will implicitly close it.
	 * A <code>ResultSet</code> object's warning chain is cleared when a new row is read.
	 * 
	 * NOTE: For FS3 and the catalog function <code>getTypeInfo</code> there is no communication with the server. All of
	 * the rows are entirely synthetic.
	 * 
	 * @return <code>true</code> if the new current row is valid; <code>false</code> if there are no more rows
	 * @exception SQLException
	 *                if a database access error occurs
	 */
	@Override
	public boolean next() throws SQLException {

		if (isAfterLast) return false;
		boolean retbool = fetchRow("GETROWN");
		++currentRow;
		if (retbool) clearWarnings();
		else isAfterLast = true;
		return retbool;
	}

	private boolean fetchRow(String func) throws SQLException {
		return fetchRow(func, Integer.MIN_VALUE);
	}

	private boolean fetchRow(String func, int xxx) throws SQLException {

		byte[] baData;
		String rtcd;
		synchronized (connectMsg.getSock()) {
			if (isEmpty) return false;
			if (catalogType == Driver.CATALOG_TYPEINFO && FSMajorVersion > 2) {
				if (currentRow < 4) rtcd = "OK";
				else rtcd = "SQL20000";
			}
			else {
				connectMsg.setFunc(func);
				connectMsg.setFileId(rsid);
				if (xxx == Integer.MIN_VALUE) connectMsg.setData(null);
				else connectMsg.setData(xxx);
				if (Driver.traceOn()) Driver.trace("ResultSet.fetchRow about to call sendMessageXXX()");
				try {
					connectMsg.sendMessage();
					Driver.trace("ResultSet.fetchRow about to call recvMessage()");
					connectMsg.recvMessage();
				}
				catch (IOException ioex) {
					throw new SQLException(ioex.getLocalizedMessage(), connectMsg.getLastErrorCode());
				}
				rtcd = connectMsg.getRtcd();
			}

			if (rtcd.startsWith("OK")) {
				if (catalogType == Driver.CATALOG_TYPEINFO && FSMajorVersion > 2) {
					baData = null;
				}
				else {
					baData = connectMsg.getData();
					if (Driver.traceOn()) Driver.trace("ResultSet@fetchRow baData = " + new String(baData));
				}
				if (FSMajorVersion > 2) {
					switch (catalogType) {
					case Driver.CATALOG_TABLES:
						baData = synthTables(baData);
						break;
					case Driver.CATALOG_COLUMNS:
						baData = synthColumns(baData);
						break;
					case Driver.CATALOG_BESTROWID:
						baData = synthBestRowId(baData);
						break;
					case Driver.CATALOG_TYPEINFO:
						baData = synthTypeInfo();
						break;
					case Driver.CATALOG_INDEXINFO:
						baData = synthIndexInfo(baData);
						break;
					case Driver.CATALOG_PRIMARY:
						baData = synthPrimaryKeysInfo(baData);
						break;
					}
					if (Driver.traceOn()) Driver.trace("ResultSet.next cooked '" + new String(baData) + "'");
				}
				if (baData != null) {
					for (int i1 = 0, start = 0; i1 < numCols && start < baData.length; start += displayWidth[i1++]) {
						byte[] valueBa = new byte[displayWidth[i1]];
						System.arraycopy(baData, start, valueBa, 0, valueBa.length);
						values[i1] = new CommonType(valueBa, colTypes[i1], colSizes[i1]);
					}
				}
				isOnValidRow = true;
				return true;
			}
			else if (rtcd.equals("SQL20000")) {
				isOnValidRow = false;
				return false;
			}
			else {
				throw new SQLException(MessageFormat.format(Driver.bun.getString("UnknRtcd"),
						new Object[] { rtcd }));
			}
		}
	}

	/*
	 * Synthesize some of the columns for DatabaseMetaData.getTables()
	 */
	private byte[] synthTables(byte[] bin) {
		int i2, offset = 0;
		StringBuffer sb = new StringBuffer(40);

		// Catalog and Schema
		blankExtend(sb, displayWidth[0]);
		blankExtend(sb, displayWidth[1]);

		// Table name
		for (i2 = 0; i2 < displayWidth[2]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Table type
		stringExtend(sb, "TABLE", displayWidth[3]);

		// Remarks
		for (i2 = 0; i2 < displayWidth[4]; i2++, offset++)
			sb.append((char) bin[offset]);

		return sb.toString().getBytes();
	}

	/*
	 * Synthesize some of the columns for DatabaseMetaData.getColumns()
	 */
	private byte[] synthColumns(byte[] bin) throws SQLException {
		int i2, offset = 0;
		char dataType = ' ';
		StringBuffer sb = new StringBuffer(80);

		// Catalog and Schema
		blankExtend(sb, displayWidth[0]);
		blankExtend(sb, displayWidth[1]);

		// Table name
		for (i2 = 0; i2 < displayWidth[2]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Column name
		for (i2 = 0; i2 < displayWidth[3]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Data type
		if (displayWidth[4] < 4 || colTypes[4] != 'N') throw new SQLException("Assertion failure");
		dataType = (char) bin[offset++];
		numberExtend(sb, getJavaType(dataType), displayWidth[4]);

		// Type name
		stringExtend(sb, getTypeName(dataType), displayWidth[5]);

		// Column size
		for (i2 = 0; i2 < displayWidth[6]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Buffer length
		numberExtend(sb, 0, displayWidth[7]);

		// Decimal digits
		if (dataType == 'C') {
			numberExtend(sb, 0, displayWidth[8]);
		}
		else {
			for (i2 = 0; i2 < displayWidth[8]; i2++, offset++)
				sb.append((char) bin[offset]);
		}

		// Num prec radix
		if (dataType == 'N') numberExtend(sb, 10, displayWidth[9]);
		else numberExtend(sb, 0, displayWidth[9]);

		// Nullable
		numberExtend(sb,
				(dataType == 'C') ? java.sql.DatabaseMetaData.columnNoNulls : java.sql.DatabaseMetaData.columnNullable,
				displayWidth[10]);

		// Remarks
		for (i2 = 0; i2 < displayWidth[11]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Column Default
		if (dataType == 'N') numberExtend(sb, 0, displayWidth[12]);
		else blankExtend(sb, displayWidth[12]);

		// SQL data type
		numberExtend(sb, 0, displayWidth[13]);

		// SQL datetime type
		numberExtend(sb, 0, displayWidth[14]);

		// Char octet length
		if (dataType == 'C') numberExtend(sb, 65500, displayWidth[15]);
		else blankExtend(sb, displayWidth[15]);

		// Ordinal position
		for (i2 = 0; i2 < displayWidth[16]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Is nullable
		stringExtend(sb, (dataType == 'C') ? "NO" : "YES", displayWidth[17]);

		return sb.toString().getBytes();
	}

	/*
	 * Synthesize some of the columns for DatabaseMetaData.getBestRowIdentifier()
	 */
	private byte[] synthBestRowId(byte[] bin) throws SQLException {
		int i2, offset = 0;
		char dataType = ' ';
		StringBuffer sb = new StringBuffer(80);

		// Scope
		numberExtend(sb, java.sql.DatabaseMetaData.bestRowSession, displayWidth[0]);

		// Column name
		for (i2 = 0; i2 < displayWidth[1]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Data type
		if (displayWidth[2] < 4 || colTypes[2] != 'N') throw new SQLException("Assertion failure");
		dataType = (char) bin[offset++];
		numberExtend(sb, getJavaType(dataType), displayWidth[2]);

		// Type name
		stringExtend(sb, getTypeName(dataType), displayWidth[3]);

		// Column size
		for (i2 = 0; i2 < displayWidth[4]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Buffer length
		blankExtend(sb, displayWidth[5]);

		// Decimal digits
		for (i2 = 0; i2 < displayWidth[6]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Pseudo column
		numberExtend(sb, java.sql.DatabaseMetaData.bestRowNotPseudo, displayWidth[7]);

		return sb.toString().getBytes();
	}

	private static final String[] typeNames = { "CHAR", "DATE", "NUMERIC", "TIMESTAMP", "TIME" };
	private static final int[] javaTypes = { getJavaType('C'), getJavaType('D'), getJavaType('N'),
			getJavaType('S'), getJavaType('T') };
	private static final int[] typePrec = { 65500, 10, 31, 23, 12 };
	private static final String[] litPref = { "'", "", "", "'", "" };
	private static final String[] creparm = { "length", "", "precision,scale", "scale", "scale" };

	private byte[] synthTypeInfo() throws SQLException {
		StringBuffer sb = new StringBuffer(80);
		short javaType;

		// Data type name
		stringExtend(sb, typeNames[currentRow], displayWidth[0]);

		// Data type
		if (displayWidth[1] < 4 || colTypes[1] != 'N') throw new SQLException("Assertion failure");
		javaType = (short) javaTypes[currentRow];
		numberExtend(sb, javaType, displayWidth[1]);

		// Precision
		numberExtend(sb, typePrec[currentRow], displayWidth[2]);

		// Literal prefix
		stringExtend(sb, litPref[currentRow], displayWidth[3]);

		// Literal suffix
		stringExtend(sb, litPref[currentRow], displayWidth[4]);

		// Create parameters
		stringExtend(sb, creparm[currentRow], displayWidth[5]);

		// Nullable
		numberExtend(sb, (javaType == java.sql.Types.CHAR) ? java.sql.DatabaseMetaData.typeNoNulls
				: java.sql.DatabaseMetaData.typeNullable, displayWidth[6]);

		// Case sensitive
		stringExtend(sb, (javaType == java.sql.Types.CHAR) ? "Y" : "N", displayWidth[7]);

		// Searchable
		numberExtend(sb, java.sql.DatabaseMetaData.typeSearchable, displayWidth[8]);

		// Unsigned
		stringExtend(sb, "N", displayWidth[9]);

		// Fixed prec scale
		stringExtend(sb, "N", displayWidth[10]);

		// Auto increment
		stringExtend(sb, "N", displayWidth[11]);

		// Local type name
		stringExtend(sb, "", displayWidth[12]);

		// Minimum scale
		numberExtend(sb, 0, displayWidth[13]);

		// Maximum scale
		switch (javaType) {
		case java.sql.Types.NUMERIC:
			numberExtend(sb, 30, displayWidth[14]);
			break;
		case java.sql.Types.TIME:
		case java.sql.Types.TIMESTAMP:
			numberExtend(sb, 3, displayWidth[14]);
			break;
		default:
			numberExtend(sb, 0, displayWidth[14]);
			break;
		}

		// sql data type, unused
		numberExtend(sb, 0, displayWidth[15]);

		// sql datetime sub, unused
		numberExtend(sb, 0, displayWidth[16]);

		// num prec radix
		numberExtend(sb, 10, displayWidth[17]);

		return sb.toString().getBytes();
	}

	/*
	 * Synthesize some of the columns for DatabaseMetaData.getIndexInfo()
	 */
	private byte[] synthIndexInfo(byte[] bin) throws SQLException {
		int i1, i2, offset = 0;
		char indexType = ' ';
		StringBuffer sb = new StringBuffer(80);

		// Catalog and Schema
		blankExtend(sb, displayWidth[0]);
		blankExtend(sb, displayWidth[1]);

		// Table name
		for (i2 = 0; i2 < displayWidth[2]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Non unique
		for (i2 = 0; i2 < displayWidth[3]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Index Qualifier
		stringExtend(sb, "", displayWidth[4]);

		// Index name
		for (i2 = 0; i2 < displayWidth[5]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Type
		indexType = (char) bin[offset++];
		switch (indexType) {
		case ' ':
			i1 = java.sql.DatabaseMetaData.tableIndexStatistic;
			break;
		default:
			i1 = java.sql.DatabaseMetaData.tableIndexOther;
			break;
		}
		numberExtend(sb, i1, displayWidth[6]);

		// Ordinal position
		for (i2 = 0; i2 < displayWidth[7]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Column name
		for (i2 = 0; i2 < displayWidth[8]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Ascending or descending
		for (i2 = 0; i2 < displayWidth[9]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Cardinality
		numberExtend(sb, 0, displayWidth[10]);

		// Pages
		numberExtend(sb, 0, displayWidth[11]);

		// Filter condition
		stringExtend(sb, "", displayWidth[12]);

		return sb.toString().getBytes();
	}

	private byte[] synthPrimaryKeysInfo(byte[] bin) {
		int i2, offset = 0;
		StringBuffer sb = new StringBuffer(80);

		// Catalog and Schema
		blankExtend(sb, displayWidth[0]);
		blankExtend(sb, displayWidth[1]);

		// Table name
		for (i2 = 0; i2 < displayWidth[2]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Column name
		for (i2 = 0; i2 < displayWidth[3]; i2++, offset++)
			sb.append((char) bin[offset]);

		// Key_Seq
		for (i2 = 0; i2 < displayWidth[4]; i2++, offset++)
			sb.append((char) bin[offset]);

		// PK_NAME
		blankExtend(sb, displayWidth[5]);

		return sb.toString().getBytes();
	}

	private static String blankPad(String in, int size) {
		char[] ac = new char[size];
		System.arraycopy(in.toCharArray(), 0, ac, 0, in.length());
		return new String(ac);
	}

	private static String blankPadLeft(String in, int size) {
		char[] ac = new char[size];
		System.arraycopy(in.toCharArray(), 0, ac, size - in.length(), in.length());
		return new String(ac);
	}

	private static void blankExtend(StringBuffer sb, int n) {
		for (int i1 = 0; i1 < n; i1++)
			sb.append(" ");
	}

	private static void numberExtend(StringBuffer sb, int num, int width) {
		String s = String.valueOf(num);
		int i1 = s.length();
		if (i1 > width) sb.append(s.substring(0, width));
		else if (i1 == width) sb.append(s);
		else sb.append(blankPadLeft(s, width));
	}

	private static void stringExtend(StringBuffer sb, String s, int width) {
		int i2 = s.length();
		if (i2 > width) sb.append(s.substring(0, width));
		else if (i2 == width) sb.append(s);
		else {
			sb.append(blankPad(s, width));
		}
	}

	private static int getJavaType(char t) {
		switch (t) {
		case 'C':
			return java.sql.Types.CHAR;
		case 'N':
			return java.sql.Types.NUMERIC;
		case 'D':
			return java.sql.Types.DATE;
		case 'T':
			return java.sql.Types.TIME;
		case 'S':
			return java.sql.Types.TIMESTAMP;
		default:
			return java.sql.Types.OTHER;
		}
	}

	/**
	 * A column may have the value of SQL NULL; wasNull reports whether the last column read had this special value.
	 * Note that you must first call getXXX on a column to try to read its value and then call wasNull() to find if the
	 * value was the SQL NULL.
	 * 
	 * @return true if last column read was SQL NULL
	 */
	@Override
	public boolean wasNull() {
		return wasNull;
	}

	private boolean checkCol(final int columnIndex) throws SQLException {
		wasNull = false;
		if (!isOnValidRow) throw new SQLException(Driver.bun.getString("InvCrntRow"));
		if (columnIndex < 1 || columnIndex > numCols) throw new SQLException(Driver.bun
				.getString("InvColIndex"));
		if (values[columnIndex - 1].isNull()) {
			wasNull = true;
		}
		return wasNull;
	}

	/*
	 * Package visibility accessor function to get the number of columns in this result set.
	 * 
	 * @return the number of columns
	 */
	int getNumCols() {
		if (!openFlag) return 0;
		return numCols;
	}

	/*
	 * Package visibility accessor function to get the type of a column.
	 * 
	 * @param the column, ZERO Based!
	 * 
	 * @return the type
	 */
	char getColType(final int col) {
		if (!openFlag || emptyRS) return ' ';
		return colTypes[col];
	}

	/*
	 * Package visibility accessor function to get the display width of a column.
	 * 
	 * @param the column, ZERO Based!
	 * 
	 * @return the width
	 */
	int getDisplayWidth(final int col) {
		if (!openFlag || emptyRS) return -1;
		return displayWidth[col];
	}

	/*
	 * Package visibility accessor function to get the name of a column.
	 * 
	 * @param the column, ZERO Based!
	 * 
	 * @return the name
	 */
	String getColumnName(final int col) {
		if (!openFlag) return null;
		return colNames[col];
	}

	/*
	 * Package visibility accessor function to get the Label of a column.
	 * 
	 * @param the column, ZERO Based!
	 * 
	 * @return the name
	 */
	String getColumnLabel(final int col) {
		if (!openFlag) return null;
		return colLabel[col];
	}

	/*
	 * Package visibility accessor function to get the Alias of a column.
	 * 
	 * @param the column, ZERO Based!
	 * 
	 * @return the name
	 */
	String getColumnAlias(final int col) {
		if (!openFlag) return null;
		return colAlias[col];
	}

	String getColumnTypeName(final int col) {
		if (!openFlag) return null;
		String ret = getTypeName(colTypes[col]);
		return (ret.length() > 0) ? ret : "UNKNOWN";
	}

	static String getTypeName(char c) {
		switch (c) {
		case 'C':
			return "CHAR";
		case 'N':
			return "NUMERIC";
		case 'D':
			return "DATE";
		case 'T':
			return "TIME";
		case 'S':
			return "TIMESTAMP";
		default:
			return "";
		}
	}

	int getPrecision(final int col) {
		if (!openFlag) return -1;
		if (colTypes[col] == 'C' || colTypes[col] == 'N') return displayWidth[col];
		else return 0;
	}

	int getScale(final int col) {
		if (!openFlag) return -1;
		int retval = -1;
		if (colTypes[col] == 'N') {
			int delim = colSizes[col].indexOf((FSMajorVersion < 3) ? ',' : ':');
			if (delim == -1) retval = 0;
			retval = Integer.parseInt(colSizes[col].substring(delim + 1));
		}
		return retval;
	}

	String getTableName(final int col) {
		return colTableName[col];
	}

	/*
	 * Package visibility accessor function to get the size of a column.
	 * 
	 * @param the column, ZERO Based!
	 * 
	 * @return the size
	 */
	String getColSize(final int col) {
		if (!openFlag || emptyRS) return null;
		return colSizes[col];
	}

	/*
	 * Package visibility accessor function to get the result set id.
	 * 
	 * @return the id string
	 */
	String getRsid() {
		if (!openFlag || emptyRS) return null;
		return rsid;
	}

	/*
	 * Package visibility accessor function to get the Message object used to communiacte with the back end
	 * 
	 * @return the Message object
	 */
	Message getConnectMsg() {
		return connectMsg;
	}

	/*
	 * Package visibility accessor function to get the current row. This is ONE based.
	 * 
	 * @return the row
	 */
	int getCurrentRow() {
		return currentRow;
	}

	@Override
	protected void finalize() throws Throwable {
		try {
			close();
		}
		finally {
			super.finalize();
		}
	}

	// --------------------------JDBC 2.0-----------------------------------

	// ---------------------------------------------------------------------
	// Getter's and Setter's
	// ---------------------------------------------------------------------

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.io.Reader</code> object.
	 * 
	 * @return a <code>java.io.Reader</code> object that contains the column value; if the value is SQL
	 *         <code>NULL</code>, the value returned is <code>null</code> in the Java programming language.
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @exception SQLException
	 *                if a database-access error occurs.
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.io.Reader getCharacterStream(int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		String tmp = values[columnIndex - 1].getString();
		return new CharArrayReader(tmp.toCharArray());
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.io.Reader</code> object.
	 * 
	 * @param columnName
	 *            the column name
	 * @return a <code>java.io.Reader</code> object that contains the column value; if the value is SQL
	 *         <code>NULL</code>, the value returned is <code>null</code> in the Java programming language.
	 * @exception SQLException
	 *                if a database-access error occurs.
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.io.Reader getCharacterStream(String columnName) throws SQLException {
		return getCharacterStream(findColumn(columnName));
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.math.BigDecimal</code> with full precision.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @return the column value (full precision); if the value is SQL <code>NULL</code>, the value returned is
	 *         <code>null</code> in the Java programming language.
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public BigDecimal getBigDecimal(int columnIndex) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getBigDecimal();
	}

	/**
	 * Gets the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.math.BigDecimal</code> with full precision.
	 * 
	 * @param columnName
	 *            the column name
	 * @return the column value (full precision); if the value is SQL <code>NULL</code>, the value returned is
	 *         <code>null</code> in the Java programming language.
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 * 
	 */
	@Override
	public BigDecimal getBigDecimal(String columnName) throws SQLException {
		return getBigDecimal(findColumn(columnName));
	}

	// ---------------------------------------------------------------------
	// Traversal/Positioning
	// ---------------------------------------------------------------------

	/**
	 * Indicates whether the cursor is before the first row in this <code>ResultSet</code> object.
	 * 
	 * @return <code>true</code> if the cursor is before the first row; <code>false</code> if the cursor is at any other
	 *         position or the result set contains no rows
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean isBeforeFirst() {
		return (currentRow == 0);
	}

	/**
	 * Indicates whether the cursor is after the last row in this <code>ResultSet</code> object.
	 * 
	 * @return <code>true</code> if the cursor is after the last row; <code>false</code> if the cursor is at any other
	 *         position or the result set contains no rows
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean isAfterLast() {
		return isAfterLast;
	}

	/**
	 * Indicates whether the cursor is on the first row of this <code>ResultSet</code> object.
	 * 
	 * @return <code>true</code> if the cursor is on the first row; <code>false</code> otherwise
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean isFirst() {
		return (currentRow == 1);
	}

	/**
	 * Indicates whether the cursor is on the last row of this <code>ResultSet</code> object. Note: Calling the method
	 * <code>isLast</code> may be expensive because the JDBC driver might need to fetch ahead one row in order to
	 * determine whether the current row is the last row in the result set.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets.
	 * 
	 * @return <code>true</code> if the cursor is on the last row; <code>false</code> otherwise
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean isLast() throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("InvOpFO"));
		if (rowCount >= 0 && currentRow == rowCount) return true;
		else if (currentRow < 1) return false;
		else if (isAfterLast) return false;
		else if (rowCount == -1) {
			// number of rows unknown, fetch ahead one row and see if we were positioned on last
			next();
			if (isAfterLast) {
				previous();
				return true;
			}
			previous();
		}
		return false;
	}

	/**
	 * Moves the cursor to the front of this <code>ResultSet</code> object, just before the first row. This method has
	 * no effect if the result set contains no rows.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets,
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or the result set type is <code>TYPE_FORWARD_ONLY</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void beforeFirst() throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("InvOpFO"));

		// Call to first() clears warnings and sets isAfterLast to false;
		// Call to previous() sets currentRow to zero.
		if (first()) previous();
	}

	/**
	 * Moves the cursor to the end of this <code>ResultSet</code> object, just after the last row. This method has no
	 * effect if the result set contains no rows.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or the result set type is <code>TYPE_FORWARD_ONLY</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void afterLast() throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("InvOpFO"));
		if (isAfterLast || rowCount == 0) return;

		// Call to last() clears warnings.
		// Call to next() sets currentRow and isAfterLast correctly.
		if (last()) next();
	}

	/**
	 * Moves the cursor to the first row in this <code>ResultSet</code> object.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets,
	 * 
	 * @return <code>true</code> if the cursor is on a valid row; <code>false</code> if there are no rows in the result
	 *         set
	 * @exception SQLException
	 *                if a database access error occurs or the result set type is <code>TYPE_FORWARD_ONLY</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean first() throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("InvOpFO"));
		boolean retbool = fetchRow("GETROWF");
		if (retbool) {
			currentRow = 1;
			clearWarnings();
			isAfterLast = false;
			isOnValidRow = true;
		}
		return retbool;
	}

	/**
	 * Moves the cursor to the last row in this <code>ResultSet</code> object.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets,
	 * 
	 * @return <code>true</code> if the cursor is on a valid row; <code>false</code> if there are no rows in the result
	 *         set
	 * @exception SQLException
	 *                if a database access error occurs or the result set type is <code>TYPE_FORWARD_ONLY</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean last() throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("InvOpFO"));
		boolean retbool = fetchRow("GETROWL");
		if (retbool) {
			currentRow = getRowCount();
			clearWarnings();
			isAfterLast = false;
			isOnValidRow = true;
		}
		return retbool;
	}

	int getRowCount() throws SQLException {
		String rtcd;
		synchronized (connectMsg.getSock()) {
			int rowct = -1;
			if (rowCount >= 0) return rowCount;
			try {
				connectMsg.setFunc("GETROWCT");
				connectMsg.setFileId(rsid);
				connectMsg.setData(null);
				connectMsg.sendMessage();
				connectMsg.recvMessage();
			}
			catch (IOException ioex) {
				throw new SQLException(ioex.getLocalizedMessage(), connectMsg.getLastErrorCode());
			}
			rtcd = connectMsg.getRtcd().toUpperCase();
			if (rtcd.equals("OK")) {
				rowct = Integer.parseInt(new String(connectMsg.getData()));
			}
			if (rowct == -1) throw new SQLException("Can't get row count");
			rowCount = rowct;
			return rowCount;
		}
	}

	/**
	 * Retrieves the current row number. The first row is number 1, the second number 2, and so on.
	 * 
	 * @return the current row number; <code>0</code> if there is no current row
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public int getRow() {
		return currentRow;
	}

	/**
	 * Moves the cursor to the given row number in this <code>ResultSet</code> object.
	 * 
	 * <p>
	 * If the row number is positive, the cursor moves to the given row number with respect to the beginning of the
	 * result set. The first row is row 1, the second is row 2, and so on.
	 * 
	 * <p>
	 * If the given row number is negative, the cursor moves to an absolute row position with respect to the end of the
	 * result set. For example, calling the method <code>absolute(-1)</code> positions the cursor on the last row;
	 * calling the method <code>absolute(-2)</code> moves the cursor to the next-to-last row, and so on.
	 * 
	 * <p>
	 * An attempt to position the cursor beyond the first/last row in the result set leaves the cursor before the first
	 * row or after the last row.
	 * 
	 * <p>
	 * <B>Note:</B> Calling <code>absolute(1)</code> is the same as calling <code>first()</code>. Calling
	 * <code>absolute(-1)</code> is the same as calling <code>last()</code>.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets,
	 * 
	 * @return <code>true</code> if the cursor is on the result set; <code>false</code> otherwise
	 * @exception SQLException
	 *                if a database access error occurs, the row is <code>0</code>, or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean absolute(int row) throws SQLException {
		if (FSMajorVersion < 3 || row == 0) throw new SQLException(Driver.bun.getString("InvOpFO"));

		// We need to know the number of rows in the set to correctly calculate currentRow.
		// If rowCount is negative then we have not yet determined this.
		// Calling the last() method will set rowCount.
		boolean retbool = fetchRow("GETROWA", row);
		if (retbool) {
			if (row > 0) currentRow = row;
			else {
				if (rowCount < 0) last();
				currentRow = rowCount + 1 + row;
			}
			clearWarnings();
			isAfterLast = false;
			isOnValidRow = true;
		}
		else {
			if (row > 0) {
				if (rowCount < 0) last();
				currentRow = rowCount + 1;
				isAfterLast = true;
			}
			else {
				currentRow = 0;
				isAfterLast = false;
			}
			isOnValidRow = false;
		}
		return retbool;
	}

	/**
	 * Moves the cursor a relative number of rows, either positive or negative. Attempting to move beyond the first/last
	 * row in the result set positions the cursor before/after the the first/last row. Calling <code>relative(0)</code>
	 * is valid, but does not change the cursor position.
	 * 
	 * <p>
	 * Note: Calling the method <code>relative(1)</code> is different from calling the method <code>next()</code>
	 * because it makes sense to call <code>next()</code> when there is no current row, for example, when the cursor is
	 * positioned before the first row or after the last row of the result set.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets,
	 * 
	 * @return <code>true</code> if the cursor is on a row; <code>false</code> otherwise
	 * @exception SQLException
	 *                if a database access error occurs, there is no current row, or the result set type is
	 *                <code>TYPE_FORWARD_ONLY</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean relative(int rows) throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("InvOpFO"));
		if (!isOnValidRow) throw new SQLException("Not on valid row.");
		if (rows == 0) return true;
		boolean retbool = fetchRow("GETROWR", rows);
		if (retbool) {
			currentRow += rows;
			clearWarnings();
			isAfterLast = false;
			isOnValidRow = true;
		}
		else {
			if (rows > 0) {
				currentRow = getRowCount();
				isAfterLast = true;
			}
			else {
				currentRow = 0;
				isAfterLast = false;
			}
			isOnValidRow = false;
		}
		return retbool;
	}

	/**
	 * Moves the cursor to the previous row in this <code>ResultSet</code> object.
	 * 
	 * <p>
	 * <B>Note:</B> Calling the method <code>previous</code> is not the same as calling the method
	 * <code>relative(-1)</code> because it makes sense to call</code>previous()</code> when there is no current row.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets,
	 * 
	 * @return <code>true</code> if the cursor is on a valid row; <code>false</code> if it is off the result set
	 * @exception SQLException
	 *                if a database access error occurs or the result set type is <code>TYPE_FORWARD_ONLY</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean previous() throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("InvOpFO"));
		boolean retbool = fetchRow("GETROWP");
		if (retbool) {
			clearWarnings();
			isAfterLast = false;
		}
		if (currentRow > 0) --currentRow;
		return retbool;
	}

	// ---------------------------------------------------------------------
	// Properties
	// ---------------------------------------------------------------------

	/**
	 * Gives a hint as to the direction in which the rows in this <code>ResultSet</code> object will be processed. The
	 * initial value is determined by the <code>Statement</code> object that produced this <code>ResultSet</code>
	 * object. The fetch direction may be changed at any time.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS2 supports only TYPE_FORWARD_ONLY result sets, For version 2 this method results in an
	 * SQLException if the direction is not FETCH_FORWARD. For version 3 this method is ignored.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or the result set type is <code>TYPE_FORWARD_ONLY</code> and the
	 *                fetch direction is not <code>FETCH_FORWARD</code>
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 * @see Statement#setFetchDirection
	 */
	@Override
	public void setFetchDirection(int direction) throws SQLException {
		if (direction != FETCH_FORWARD && FSMajorVersion < 3) throw new SQLException(Driver.bun
				.getString("InvOpFO"));
	}

	/**
	 * Returns the fetch direction for this <code>ResultSet</code> object.
	 * 
	 * @return the current fetch direction for this <code>ResultSet</code> object
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public int getFetchDirection() throws SQLException {
		return FETCH_FORWARD;
	}

	/**
	 * Gives the JDBC driver a hint as to the number of rows that should be fetched from the database when more rows are
	 * needed for this <code>ResultSet</code> object. If the fetch size specified is zero, the JDBC driver ignores the
	 * value and is free to make its own best guess as to what the fetch size should be. The default value is set by the
	 * <code>Statement</code> object that created the result set. The fetch size may be changed at any time.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> This method is ignored.
	 * 
	 * @param rows
	 *            the number of rows to fetch
	 * @exception SQLException
	 *                if a database access error occurs or the condition <code>0 <= rows <= this.getMaxRows()</code> is
	 *                not satisfied
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void setFetchSize(int rows) throws SQLException {
	}

	/**
	 * 
	 * Returns the fetch size for this <code>ResultSet</code> object.
	 * 
	 * @return the current fetch size for this <code>ResultSet</code> object
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public int getFetchSize() throws SQLException {
		return 0;
	}

	/**
	 * Returns the type of this <code>ResultSet</code> object. The type is determined by the <code>Statement</code>
	 * object that created the result set.
	 * 
	 * @return <code>TYPE_FORWARD_ONLY</code>, <code>TYPE_SCROLL_INSENSITIVE</code>, or
	 *         <code>TYPE_SCROLL_SENSITIVE</code>
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public int getType() throws SQLException {
		if (FSMajorVersion < 3) return TYPE_FORWARD_ONLY;
		else return TYPE_SCROLL_INSENSITIVE;
	}

	/**
	 * Returns the concurrency mode of this <code>ResultSet</code> object. The concurrency used is determined by the
	 * <code>Statement</code> object that created the result set.
	 * 
	 * @return the concurrency type, either <code>CONCUR_READ_ONLY</code> or <code>CONCUR_UPDATABLE</code>
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public int getConcurrency() throws SQLException {
		return concurrency;
	}

	// ---------------------------------------------------------------------
	// Updates
	// ---------------------------------------------------------------------

	/**
	 * Indicates whether the current row has been updated. The value returned depends on whether or not the result set
	 * can detect updates.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> Since the FS2 system does not support current row updates, this method will always return false
	 * 
	 * @return <code>true</code> if the row has been visibly updated by the owner or another, and updates are detected
	 * @exception SQLException
	 *                if a database access error occurs
	 * 
	 * @see DatabaseMetaData#updatesAreDetected
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean rowUpdated() throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		return false;
	}

	/**
	 * Indicates whether the current row has had an insertion. The value returned depends on whether or not this
	 * <code>ResultSet</code> object can detect visible inserts.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> Since the FS2 system does not support current row updates, this method will always return false
	 * 
	 * @return <code>true</code> if a row has had an insertion and insertions are detected; <code>false</code> otherwise
	 * @exception SQLException
	 *                if a database access error occurs
	 * 
	 * @see DatabaseMetaData#insertsAreDetected
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean rowInserted() throws SQLException {
		return false;
	}

	/**
	 * Indicates whether a row has been deleted. A deleted row may leave a visible "hole" in a result set. This method
	 * can be used to detect holes in a result set. The value returned depends on whether or not this
	 * <code>ResultSet</code> object can detect deletions.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> Since the FS2 system does not support current row updates, this method will always return false
	 * 
	 * @return <code>true</code> if a row was deleted and deletions are detected; <code>false</code> otherwise
	 * @exception SQLException
	 *                if a database access error occurs
	 * 
	 * @see DatabaseMetaData#deletesAreDetected
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public boolean rowDeleted() throws SQLException {
		return false;
	}

	/**
	 * Updates the designated column with an ascii stream value. The <code>updateXXX</code> methods are used to update
	 * column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @param length
	 *            the length of the stream
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateAsciiStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		byte[] ba = new byte[length];
		try {
			x.read(ba, 0, length);
		}
		catch (IOException e) {
			throw new SQLException(e.getLocalizedMessage());
		}
		values[columnIndex - 1].setBytes(ba);
	}

	/**
	 * Updates the designated column with an ascii stream value. The <code>updateXXX</code> methods are used to update
	 * column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @param length
	 *            the length of the stream
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateAsciiStream(String columnName, java.io.InputStream x, int length) throws SQLException {
		if (FSMajorVersion < 3) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateAsciiStream(findColumn(columnName), x, length);
	}

	/**
	 * Updates the designated column with a <code>java.math.BigDecimal</code> value. The <code>updateXXX</code> methods
	 * are used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBigDecimal(int columnIndex, BigDecimal x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBytes(x.toString().getBytes());
	}

	/**
	 * Updates the designated column with a <code>java.sql.BigDecimal</code> value. The <code>updateXXX</code> methods
	 * are used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateBigDecimal(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with a binary stream value. The <code>updateXXX</code> methods are used to update
	 * column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @param length
	 *            the length of the stream
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBinaryStream(int columnIndex, java.io.InputStream x, int length) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		byte[] ba = new byte[length];
		try {
			x.read(ba, 0, length);
		}
		catch (IOException e) {
			throw new SQLException(e.getLocalizedMessage());
		}
		values[columnIndex - 1].setBytes(ba);
	}

	/**
	 * Updates the designated column with a binary stream value. The <code>updateXXX</code> methods are used to update
	 * column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @param length
	 *            the length of the stream
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBinaryStream(String columnName, java.io.InputStream x, int length) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateBinaryStream(findColumn(columnName), x, length);
	}

	/**
	 * Updates the designated column with a <code>boolean</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBoolean(int columnIndex, boolean x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBoolean(x);
	}

	/**
	 * Updates the designated column with a <code>boolean</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBoolean(String columnName, boolean x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateBoolean(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with a <code>byte</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateByte(int columnIndex, byte x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBytes(new byte[] { x });
	}

	/**
	 * Updates the designated column with a <code>byte</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateByte(String columnName, byte x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateByte(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with a <code>byte</code> array value. The <code>updateXXX</code> methods are used
	 * to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update
	 * the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to
	 * update the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBytes(int columnIndex, byte x[]) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBytes(x);
	}

	/**
	 * Updates the designated column with a <code>byte</code> array value. The <code>updateXXX</code> methods are used
	 * to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update
	 * the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to
	 * update the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateBytes(String columnName, byte x[]) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateBytes(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with a character stream value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @param length
	 *            the length of the stream
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateCharacterStream(int columnIndex, java.io.Reader x, int length) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		ByteArrayOutputStream baos = new ByteArrayOutputStream(length);
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(baos));
		try {
			for (int i1 = 0; i1 < length; i1++) {
				bw.write(x.read());
			}
			bw.flush();
		}
		catch (IOException e) {
			throw new SQLException(e.getLocalizedMessage());
		}
		values[columnIndex - 1].setBytes(baos.toByteArray());
	}

	/**
	 * Updates the designated column with a character stream value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @param length
	 *            the length of the stream
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateCharacterStream(String columnName, java.io.Reader reader, int length)
			throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateCharacterStream(findColumn(columnName), reader, length);
	}

	/**
	 * Updates the designated column with a <code>java.sql.Date</code> value. The <code>updateXXX</code> methods are
	 * used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateDate(int columnIndex, java.sql.Date x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setDate(x);
	}

	/**
	 * Updates the designated column with a <code>java.sql.Date</code> value. The <code>updateXXX</code> methods are
	 * used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateDate(String columnName, java.sql.Date x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateDate(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with a <code>Double</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateDouble(int columnIndex, double x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBytes(String.valueOf(x).getBytes());
	}

	/**
	 * Updates the designated column with a <code>Double</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateDouble(String columnName, double x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateDouble(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with a <code>float</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateFloat(int columnIndex, float x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBytes(String.valueOf(x).getBytes());
	}

	/**
	 * Updates the designated column with a <code>float</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateFloat(String columnName, float x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateFloat(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with an <code>int</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateInt(int columnIndex, int x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBytes(String.valueOf(x).getBytes());
	}

	/**
	 * Updates the designated column with an <code>int</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateInt(String columnName, int x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateInt(findColumn(columnName), x);
	}

	/**
	 * Updates the designated column with an <code>long</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateLong(int columnIndex, long x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setBytes(String.valueOf(x).getBytes());
	}

	/**
	 * Updates the designated column with an <code>long</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateLong(String columnName, long x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateLong(findColumn(columnName), x);
	}

	/**
	 * Gives a nullable column a null value.
	 * 
	 * The <code>updateXXX</code> methods are used to update column values in the current row or the insert row. The
	 * <code>updateXXX</code> methods do not update the underlying database; instead the <code>updateRow</code> or
	 * <code>insertRow</code> methods are called to update the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateNull(int columnIndex) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		values[columnIndex - 1].setNull();
	}

	/**
	 * Gives a nullable column a null value.
	 * 
	 * The <code>updateXXX</code> methods are used to update column values in the current row or the insert row. The
	 * <code>updateXXX</code> methods do not update the underlying database; instead the <code>updateRow</code> or
	 * <code>insertRow</code> methods are called to update the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateNull(String columnName) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		updateNull(findColumn(columnName));
	}

	/**
	 * Updates the designated column with an <code>Object</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateObject(int columnIndex, Object x) throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		if (checkCol(columnIndex)) return;
		// TODO Deal with this!
	}

	/**
	 * Updates the designated column with an <code>Object</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateObject(String columnName, Object x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with an <code>Object</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @param scale
	 *            for <code>java.sql.Types.DECIMA</code> or <code>java.sql.Types.NUMERIC</code> types, this is the
	 *            number of digits after the decimal point. For all other types this value will be ignored.
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateObject(int columnIndex, Object x, int scale) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with an <code>Object</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @param scale
	 *            for <code>java.sql.Types.DECIMA</code> or <code>java.sql.Types.NUMERIC</code> types, this is the
	 *            number of digits after the decimal point. For all other types this value will be ignored.
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateObject(String columnName, Object x, int scale) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with an <code>short</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateShort(int columnIndex, short x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with an <code>short</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateShort(String columnName, short x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with an <code>String</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateString(int columnIndex, String x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with an <code>String</code> value. The <code>updateXXX</code> methods are used to
	 * update column values in the current row or the insert row. The <code>updateXXX</code> methods do not update the
	 * underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called to update
	 * the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateString(String columnName, String x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with a <code>java.sql.Time</code> value. The <code>updateXXX</code> methods are
	 * used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateTime(int columnIndex, java.sql.Time x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with a <code>java.sql.Time</code> value. The <code>updateXXX</code> methods are
	 * used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateTime(String columnName, java.sql.Time x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with a <code>java.sql.Timestamp</code> value. The <code>updateXXX</code> methods
	 * are used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateTimestamp(int columnIndex, java.sql.Timestamp x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the designated column with a <code>java.sql.Timestamp</code> value. The <code>updateXXX</code> methods
	 * are used to update column values in the current row or the insert row. The <code>updateXXX</code> methods do not
	 * update the underlying database; instead the <code>updateRow</code> or <code>insertRow</code> methods are called
	 * to update the database.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @param columnName
	 *            the name of the column
	 * @param x
	 *            the new column value
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Inserts the contents of the insert row into this <code>ResultSet</code> objaect and into the database. The cursor
	 * must be on the insert row when this method is called.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs, if this method is called when the cursor is not on the insert
	 *                row, or if not all of non-nullable columns in the insert row have been given a value
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void insertRow() throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Updates the underlying database with the new contents of the current row of this <code>ResultSet</code> object.
	 * This method cannot be called when the cursor is on the insert row.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> The FS2 system does not support current row updates.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or if this method is called when the cursor is on the insert row
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void updateRow() throws SQLException {
		synchronized (connectMsg.getSock()) {
			if (concurrency == CONCUR_READ_ONLY) { throw new SQLException(Driver.bun.getString("NoUpdates")); }
			StringBuffer sb = null;
			connectMsg.setFunc("PSUPDATE");
			connectMsg.setFileId(rsid);
			for (int i1 = 0; i1 < values.length; i1++) {
				if (!values[i1].isUpdated()) continue;
				if (sb == null) sb = new StringBuffer();
				sb.append(colNames[i1]);
				sb.append(" = '");
				sb.append(values[i1].getString());
				sb.append("',");
			}
			if (sb == null) return;
			connectMsg.setData(sb.substring(0, sb.length()));
			try {
				connectMsg.sendMessage();
				connectMsg.recvMessage(); // Must flush the 'OK' from incoming pipe
			}
			catch (IOException ioex) {
				throw new SQLException(ioex.getLocalizedMessage());
			}
			for (int i1 = 0; i1 < values.length; i1++) {
				if (values[i1].isUpdated()) values[i1].clearUpdated();
			}
		}
	}

	/**
	 * Deletes the current row from this <code>ResultSet</code> object and from the underlying database. This method
	 * cannot be called when the cursor is on the insert row.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> The FS2 system does not support current row deletes.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or if this method is called when the cursor is on the insert row
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void deleteRow() throws SQLException {
		synchronized (connectMsg.getSock()) {
			if (concurrency == CONCUR_READ_ONLY || !isOnValidRow) { throw new SQLException(Driver.bun
					.getString("NoUpdates")); }
			connectMsg.setFunc("PSDELETE");
			connectMsg.setFileId(rsid);
			connectMsg.setData(null);
			try {
				connectMsg.sendMessage();
				connectMsg.recvMessage(); // Must flush the 'OK' from incoming pipe
			}
			catch (IOException ioex) {
				throw new SQLException(ioex.getLocalizedMessage());
			}
			isOnValidRow = false;
			values = null;
			warnings.removeAllElements();
		}
	}

	/**
	 * Refreshes the current row with its most recent value in the database. This method cannot be called when the
	 * cursor is on the insert row.
	 * 
	 * <P>
	 * The <code>refreshRow</code> method provides a way for an application to explicitly tell the JDBC driver to
	 * refetch a row(s) from the database. An application may want to call <code>refreshRow</code> when caching or
	 * prefetching is being done by the JDBC driver to fetch the latest value of a row from the database. The JDBC
	 * driver may actually refresh multiple rows at once if the fetch size is greater than one.
	 * 
	 * <P>
	 * All values are refetched subject to the transaction isolation level and cursor sensitivity. If
	 * <code>refreshRow</code> is called after calling an <code>updateXXX</code> method, but before calling the method
	 * <code>updateRow</code>, then the updates made to the row are lost. Calling the method <code>refreshRow</code>
	 * frequently will likely slow performance.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or if this method is called when the cursor is on the insert row
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void refreshRow() throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Cancels the updates made to the current row in this <code>ResultSet</code> object. This method may be called
	 * after calling an <code>updateXXX</code> method(s) and before calling the method <code>updateRow</code> to roll
	 * back the updates made to a row. If no updates have been made or <code>updateRow</code> has already been called,
	 * this method has no effect.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> The FS2 system does not support current row updates
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or if this method is called when the cursor is on the insert row
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void cancelRowUpdates() throws SQLException {
		if (concurrency == CONCUR_READ_ONLY) throw new SQLException(Driver.bun.getString("NoUpdates"));
		for (int i1 = 0; i1 < values.length; i1++) {
			if (values[i1].isUpdated()) values[i1].revert();
		}
	}

	/**
	 * Moves the cursor to the insert row. The current cursor position is remembered while the cursor is positioned on
	 * the insert row.
	 * 
	 * The insert row is a special row associated with an updatable result set. It is essentially a buffer where a new
	 * row may be constructed by calling the <code>updateXXX</code> methods prior to inserting the row into the result
	 * set.
	 * 
	 * Only the <code>updateXXX</code>, <code>getXXX</code>, and <code>insertRow</code> methods may be called when the
	 * cursor is on the insert row. All of the columns in a result set must be given a value each time this method is
	 * called before calling <code>insertRow</code>. An <code>updateXXX</code> method must be called before a
	 * <code>getXXX</code> method can be called on a column value.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or the result set is not updatable
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void moveToInsertRow() throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Moves the cursor to the remembered cursor position, usually the current row. This method has no effect if the
	 * cursor is not on the insert row.
	 * 
	 * <P>
	 * <B>FS2 NOTE:</B> Since the FS2 system does not support current row updates, this method will always result in an
	 * SQLException.
	 * 
	 * @exception SQLException
	 *                if a database access error occurs or the result set is not updatable
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public void moveToCurrentRow() throws SQLException {
		throw new SQLException(Driver.bun.getString("NoUpdates"));
	}

	/**
	 * Returns the <code>Statement</code> object that produced this <code>ResultSet</code> object. If the result set was
	 * generated some other way, such as by a <code>DatabaseMetaData</code> method, this method returns
	 * <code>null</code>.
	 * 
	 * @return the <code>Statment</code> object that produced this <code>ResultSet</code> object or <code>null</code> if
	 *         the result set was produced some other way
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Statement getStatement() {
		return myStatement;
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>Ref</code> object in the Java programming language.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS does not support the Ref data type.
	 * 
	 * @param i
	 *            the first column is 1, the second is 2, ...
	 * @return a <code>Ref</code> object representing an SQL <code>REF</code> va
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Ref getRef(int i) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoType") + " : Ref");
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>Ref</code> object in the Java programming language.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS does not support the Ref data type.
	 * 
	 * @param colName
	 *            the column name
	 * @return a <code>Ref</code> object representing the SQL <code>REF</code> value the specified column
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Ref getRef(String colName) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoType") + " : Ref");
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>Blob</code> object in the Java programming language.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS does not support the Blob data type.
	 * 
	 * @param i
	 *            the first column is 1, the second is 2, ...
	 * @return a <code>Blob</code> object representing the SQL <code>BLOB</code> the specified column
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Blob getBlob(int i) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoType") + " : Blob");
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>Blob</code> object in the Java programming language.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS does not support the Blob data type.
	 * 
	 * @param colName
	 *            the name of the column from which to retrieve the value
	 * @return a <code>Blob</code> object representing the SQL <code>BLOB</code> the specified column
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Blob getBlob(String colName) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoType") + " : Blob");
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>Clob</code> object in the Java programming language.
	 * 
	 * @param i
	 *            the first column is 1, the second is 2, ...
	 * @return a <code>Clob</code> object representing the SQL <code>CLOB</code> the specified column
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Clob getClob(int i) throws SQLException {
		if (checkCol(i)) return null;
		return new Clob(values[i - 1].getString());
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>Clob</code> object in the Java programming language.
	 * 
	 * @param colName
	 *            the column name
	 * @return a <code>Clob</code> object representing the SQL <code>CLOB</code> the specified column
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Clob getClob(String colName) throws SQLException {
		return getClob(findColumn(colName));
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as an
	 * <code>Array</code> object in the Java programming language.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS does not support the Array data type.
	 * 
	 * @param i
	 *            the first column is 1, the second is 2, ...
	 * @return an <code>Array</code> object representing the SQL <code>ARRAY</co
	 *         the specified column
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Array getArray(int i) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoType") + " : Array");
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as an
	 * <code>Array</code> object in the Java programming language.
	 * 
	 * <P>
	 * <B>FS NOTE:</B> FS does not support the Array data type.
	 * 
	 * @param i
	 *            the first column is 1, the second is 2, ...
	 * @return an <code>Array</code> object representing the SQL <code>ARRAY</co
	 *         the specified column
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Array getArray(String colName) throws SQLException {
		throw new SQLException(Driver.bun.getString("NoType") + " : Array");
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Date</code> object in the Java programming language. This method uses the given calendar to
	 * construct an appropriate millisecond value for the date if the underlying database does not store timezone
	 * information.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param cal
	 *            the <code>java.util.Calendar</code> object to use in constructing the date
	 * @return the column value as a <code>java.sql.Date</code> object; if the value is SQL <code>NULL</code>, the value
	 *         returned is <code>null</code> in the Java programming language
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Date getDate(int columnIndex, java.util.Calendar cal) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getDate(cal);
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Date</code> object in the Java programming language. This method uses the given calendar to
	 * construct an appropriate millisecond value for the date if the underlying database does not store timezone
	 * information.
	 * 
	 * @param columnName
	 *            the SQL name of the column from which to retrieve the value
	 * @param cal
	 *            the <code>java.util.Calendar</code> object to use in constructing the date
	 * @return the column value as a <code>java.sql.Date</code> object; if the value is SQL <code>NULL</code>, the value
	 *         returned is <code>null</code> in the Java programming language
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Date getDate(String columnName, java.util.Calendar cal) throws SQLException {
		return getDate(findColumn(columnName), cal);
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Time</code> object in the Java programming language. This method uses the given calendar to
	 * construct an appropriate millisecond value for the time if the underlying database does not store timezone
	 * information.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param cal
	 *            the <code>java.util.Calendar</code> object to use in constructing the time
	 * @return the column value as a <code>java.sql.Time</code> object; if the value is SQL <code>NULL</code>, the value
	 *         returned is <code>null</code> in the Java programming language
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Time getTime(int columnIndex, java.util.Calendar cal) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getTime(cal);
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Time</code> object in the Java programming language. This method uses the given calendar to
	 * construct an appropriate millisecond value for the time if the underlying database does not store timezone
	 * information.
	 * 
	 * @param columnName
	 *            the SQL name of the column
	 * @param cal
	 *            the <code>java.util.Calendar</code> object to use in constructing the time
	 * @param cal
	 *            the calendar to use in constructing the time
	 * @return the column value as a <code>java.sql.Time</code> object; if the value is SQL <code>NULL</code>, the value
	 *         returned is <code>null</code> in the Java programming language
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Time getTime(String columnName, java.util.Calendar cal) throws SQLException {
		return getTime(findColumn(columnName), cal);
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Timestamp</code> object in the Java programming language. This method uses the given calendar to
	 * construct an appropriate millisecond value for the timestamp if the underlying database does not store timezone
	 * information.
	 * 
	 * @param columnIndex
	 *            the first column is 1, the second is 2, ...
	 * @param cal
	 *            the <code>java.util.Calendar</code> object to use in constructing the timestamp
	 * @return the column value as a <code>java.sql.Timestamp</code> object; if the value is SQL <code>NULL</code>, the
	 *         value returned is <code>null</code> in the Java programming language
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Timestamp getTimestamp(int columnIndex, java.util.Calendar cal) throws SQLException {
		if (checkCol(columnIndex)) return null;
		return values[columnIndex - 1].getTimestamp(cal);
	}

	/**
	 * Returns the value of the designated column in the current row of this <code>ResultSet</code> object as a
	 * <code>java.sql.Timestamp</code> object in the Java programming language. This method uses the given calendar to
	 * construct an appropriate millisecond value for the timestamp if the underlying database does not store timezone
	 * information.
	 * 
	 * @param columnName
	 *            the SQL name of the column
	 * @param cal
	 *            the <code>java.util.Calendar</code> object to use in constructing the date
	 * @return the column value as a <code>java.sql.Timestamp</code> object; if the value is SQL <code>NULL</code>, the
	 *         value returned is <code>null</code> in the Java programming language
	 * @exception SQLException
	 *                if a database access error occurs
	 * @since 1.2
	 * @see <a href="package-summary.html#2.0 API">What Is in the JDBC 2.0 API</a>
	 */
	@Override
	public java.sql.Timestamp getTimestamp(String columnName, java.util.Calendar cal) throws SQLException {
		return getTimestamp(findColumn(columnName), cal);
	}

	void setCatalogType(int ct) {
		catalogType = ct;
	}

	@Override
	public URL getURL(int arg0) throws SQLException {
		return null;
	}

	@Override
	public URL getURL(String arg0) throws SQLException {
		return null;
	}

	@Override
	public void updateArray(int arg0, java.sql.Array arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	@Override
	public void updateArray(String arg0, java.sql.Array arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	@Override
	public void updateBlob(int arg0, java.sql.Blob arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	@Override
	public void updateBlob(String arg0, java.sql.Blob arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	@Override
	public void updateClob(int arg0, java.sql.Clob arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	@Override
	public void updateClob(String arg0, java.sql.Clob arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	@Override
	public void updateRef(int arg0, java.sql.Ref arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	@Override
	public void updateRef(String arg0, java.sql.Ref arg1) throws SQLException {
		throw new SQLException("not supported");
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see java.sql.ResultSet#getHoldability()
	 */
	@Override
	public int getHoldability() throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public Reader getNCharacterStream(int columnIndex) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public Reader getNCharacterStream(String columnLabel) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public String getNString(int columnIndex) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public String getNString(String columnLabel) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean isClosed() throws SQLException {
		return openFlag;
	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateAsciiStream(int columnIndex, InputStream x, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateAsciiStream(String columnLabel, InputStream x, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBinaryStream(int columnIndex, InputStream x, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBinaryStream(String columnLabel, InputStream x, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBlob(int columnIndex, InputStream inputStream, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateBlob(String columnLabel, InputStream inputStream, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateClob(int columnIndex, Reader reader) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateClob(String columnLabel, Reader reader) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateClob(int columnIndex, Reader reader, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateClob(String columnLabel, Reader reader, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateNCharacterStream(int columnIndex, Reader x, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateNCharacterStream(String columnLabel, Reader reader, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateNClob(int columnIndex, Reader reader) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateNClob(String columnLabel, Reader reader) throws SQLException {
		throw new SQLFeatureNotSupportedException();

	}

	@Override
	public void updateNClob(int columnIndex, Reader reader, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateNClob(String columnLabel, Reader reader, long length) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateNString(int columnIndex, String nString) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateNString(String columnLabel, String nString) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	@Override
	public RowId getRowId(int columnIndex) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public RowId getRowId(String columnLabel) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateRowId(int columnIndex, RowId x) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateRowId(String columnLabel, RowId x) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateNClob(int columnIndex, NClob nClob) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateNClob(String columnLabel, NClob nClob) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public NClob getNClob(int columnIndex) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public NClob getNClob(String columnLabel) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public SQLXML getSQLXML(int columnIndex) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public SQLXML getSQLXML(String columnLabel) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateSQLXML(int columnIndex, SQLXML xmlObject) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public void updateSQLXML(String columnLabel, SQLXML xmlObject) throws SQLException {
		throw new SQLFeatureNotSupportedException();
	}

	@Override
	public <T> T getObject(int columnIndex, Class<T> type) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public <T> T getObject(String columnLabel, Class<T> type) throws SQLException {
		// TODO Auto-generated method stub
		return null;
	}

}
